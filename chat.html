<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https:; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; connect-src 'self' blob: data: http://localhost:3000 https://api.elevenlabs.io https://api.openai.com https://*.supabase.co wss://*.supabase.co https://infragrid.v.network https://*.v.network https://vrm-eliza-ai-girlfriend.vercel.app; media-src 'self' blob: data:; object-src 'none'; base-uri 'self'; form-action 'self';">
    <title data-i18n-title="app.title">AI Girlfriend Chat Game 🌸</title>
    <link rel="icon" type="image/png" href="assets/wallet/favicon-circle.png">
    <link rel="stylesheet" href="chat-ui.css">
    <link rel="stylesheet" href="wallet-ui.css">
    <link rel="stylesheet" href="chat-responsive.css">
    
    <!-- Configuration files -->
    <script src="config.js"></script>
    <!-- Auto-generated character i18n (must load before i18n.js) -->
    <script src="i18n.characters.generated.js"></script>
    <!-- Internationalization support -->
    <script src="i18n.js"></script>
    <!-- Memory system handled by ElizaOS backend -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* VRM display area - full screen */
        .vrm-container {
            width: 100%;
            height: 100%;
            position: relative;
            /* Remove CSS background to show Three.js scene background */
            background: transparent;
        }

        /* 🎤 Voice play button */
        .voice-play-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 5px;
            margin-left: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .voice-play-btn:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .voice-play-btn:active {
            transform: translateY(0);
        }

        /* AI dialogue bubble */
        .ai-speech-bubble {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 220, 220, 0.95);
            color: #333;
            padding: 18px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            max-width: 450px;
            min-width: 250px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            opacity: 0;
            animation: bubbleFadeIn 0.5s forwards;
            z-index: 1100;
            line-height: 1.5;
            letter-spacing: 0.5px;
        }

        .ai-speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 18px solid rgba(220, 220, 220, 0.95);
        }

        @keyframes bubbleFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes bubbleFadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .vrm-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }



        /* Retro music player */
        .music-controls {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 280px;
            height: 120px;
            background: linear-gradient(135deg, #e8b4ff 0%, #d19cff 50%, #b96fff 100%);
            border-radius: 15px;
            border: 6px solid #4a2c5a;
            color: #2d1b3d;
            z-index: 1001;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3), inset 0 2px 0 rgba(255, 255, 255, 0.4);
            font-family: 'Arial', sans-serif;
        }

        .music-window-title {
            background: linear-gradient(90deg, #ffb366 0%, #ffa64d 100%);
            margin: -15px -15px 10px -15px;
            padding: 8px 15px;
            border-radius: 9px 9px 0 0;
            font-size: 12px;
            font-weight: bold;
            color: #2d1b3d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .window-controls {
            display: flex;
            gap: 5px;
        }

        .window-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .minimize-btn { background: #ffd23f; }
        .maximize-btn { background: #28ca42; }
        .close-btn { background: #ff5f57; }

        .music-player-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .music-controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .music-control-btn {
            width: 35px;
            height: 25px;
            background: #6c4a7a;
            border: 2px solid #2d1b3d;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .music-control-btn:hover {
            background: #8b5fa3;
            transform: translateY(-1px);
        }

        .play-btn {
            width: 45px !important;
            background: #4a7c59 !important;
        }

        .play-btn:hover {
            background: #5d9973 !important;
        }

        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .volume-slider {
            width: 120px;
            height: 4px;
            border-radius: 2px;
            background: #4a2c5a;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: #ffb366;
            cursor: pointer;
            border: 1px solid #2d1b3d;
        }

        .volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: #ffb366;
            cursor: pointer;
            border: 1px solid #2d1b3d;
        }

        .volume-label {
            font-size: 10px;
            min-width: 25px;
            font-weight: bold;
            text-align: right;
        }

        /* Language switcher */
        .language-toggle {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: linear-gradient(135deg, #ff9a56 0%, #ffad56 50%, #ffc056 100%);
            border-radius: 10px;
            border: 4px solid #4a2c5a;
            padding: 8px 15px;
            z-index: 1002;
            scale: 0.6;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #2d1b3d;
            font-weight: bold;
            font-size: 12px;
        }

        .language-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #4a2c5a;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            color: #2d1b3d;
            transition: all 0.2s ease;
        }

        .language-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }

        .language-btn.active {
            background: #4a2c5a;
            color: white;
        }


        .emotion-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .emotion-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .emotion-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .emotion-btn.active {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .vrm-container {
                width: 100%;
                height: 100vh;
            }
        }

        /* Animation effects */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Back button */
        .back-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(255, 107, 157, 0.8);
            transform: translateY(-2px);
        }

        /* Wallet status display */
        .wallet-status-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            scale: 0.6;
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .wallet-avatar svg {
            color: #8b5cf6;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 5px;
        }

        .wallet-disconnect {
            background: rgba(255, 69, 58, 0.8);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .wallet-disconnect:hover {
            background: rgba(255, 69, 58, 1);
        }

        /* Connect wallet button */
        .connect-wallet-btn {
            background: linear-gradient(135deg, #9945ff, #14f195);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(153, 69, 255, 0.4);
        }

        /* Unauthorized interface */
        .unauthorized-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .unauthorized-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            color: #333;
        }

        .unauthorized-content h2 {
            margin-bottom: 20px;
            color: #ff6b9d;
        }

        .unauthorized-content p {
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .connect-wallet-btn {
            background: linear-gradient(135deg, #9945ff, #14f195);
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(153, 69, 255, 0.4);
        }

        /* Floating chat box */
        .floating-chat {
            position: fixed;
            /* Avoid translateY-based centering to prevent vertical jitter when hovering */
            top: 120px;
            right: 20px;
            transform: none;
            width: 416px;
            height: 754px;
            background: #F5F3F0;
            border-radius: 33px;
            border: 10px solid #2C1810;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4), 
                        0 0 30px rgba(44, 24, 16, 0.2),
                        inset 0 2px 0 rgba(255, 255, 255, 0.3);
            z-index: 1000;
            cursor: move;
            user-select: none;
            overflow: hidden;
        }


        .floating-chat.dragging {
            transform: scale(1.05);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5), 
                        0 0 40px rgba(255, 182, 193, 0.8),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            cursor: grabbing;
        }

        /* Mobile top bar style chat header */
        .chat-window-header {
            border-radius: 23px 23px 0 0;
            padding: 0;
            border-bottom: none;
            display: flex;
            flex-direction: column;
            cursor: grab;
            user-select: none;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .chat-window-header:active {
            cursor: grabbing;
        }

        /* Real mobile status bar */
        .phone-status-bar {
            background: #000000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 16px;
            font-size: 14px;
            color: white;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            height: 24px;
            border-radius: 23px 23px 0 0;
            width: 100%;
            box-sizing: border-box;
        }

        .status-left {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .carrier-info {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .network-type {
            font-size: 14px;
            font-weight: 600;
        }

        .status-center {
            flex: 1;
            display: flex;
            justify-content: center;
        }

        .time-display {
            font-weight: 700;
            font-size: 14px;
            letter-spacing: -0.2px;
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            justify-content: flex-end;
        }

        .status-icon {
            display: flex;
            align-items: center;
        }

        .battery-percentage {
            font-size: 14px;
            font-weight: 600;
            margin-right: 2px;
        }

        /* Anime-style chat title area */
        .chat-title-area {
            position: relative;
            padding: 16px 20px;
            background: linear-gradient(135deg, 
                #FF6B9D 0%, 
                #C44569 25%, 
                #7B68EE 50%, 
                #9B59B6 75%, 
                #E056FD 100%);
            border-bottom: none;
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Anime-style background decoration */
        .chat-title-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 182, 193, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Anime-style star decoration */
        .chat-title-area::after {
            content: '✨🌸✨';
            position: absolute;
            top: 8px;
            right: 20px;
            font-size: 12px;
            opacity: 0.7;
            animation: sparkle 3s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .chat-user-info {
            display: flex;
            align-items: center;
            gap: 14px;
            position: relative;
            z-index: 2;
        }

        /* Cute avatar design - using same avatar as chat bubble */
        .chat-user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: url('profile-pic/alice-pf.png') center/cover;
            border: 3px solid rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            box-shadow: 
                0 4px 15px rgba(255, 182, 193, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.6);
            animation: avatarFloat 4s ease-in-out infinite;
        }

        /* Different character avatars for title bar */
        .character-fliza .chat-user-avatar {
            background-image: url('profile-pic/fliza-pf.png');
        }

        .character-alice .chat-user-avatar {
            background-image: url('profile-pic/alice-pf.png');
        }

        .character-ash .chat-user-avatar {
            background-image: url('profile-pic/ash-pf.png');
        }

        .character-bobo .chat-user-avatar {
            background-image: url('profile-pic/bobo-pf.png');
        }

        .character-elinyaa .chat-user-avatar {
            background-image: url('profile-pic/elinyaa-pf.png');
        }

        .character-imeris .chat-user-avatar {
            background-image: url('profile-pic/imeris-pf.png');
        }

        .character-kyoko .chat-user-avatar {
            background-image: url('profile-pic/kyoko-pf.png');
        }

        .character-lena .chat-user-avatar {
            background-image: url('profile-pic/lena-pf.png');
        }

        .character-lilium .chat-user-avatar {
            background-image: url('profile-pic/lilium.png');
        }

        .character-maple .chat-user-avatar {
            background-image: url('profile-pic/maple-pf.png');
        }

        .character-miru .chat-user-avatar {
            background-image: url('profile-pic/Miru-pf.png');
        }

        .character-miumiu .chat-user-avatar {
            background-image: url('profile-pic/miumiu-pf.png');
        }

        .character-neco .chat-user-avatar {
            background-image: url('profile-pic/neco-pf.png');
        }

        .character-nekona .chat-user-avatar {
            background-image: url('profile-pic/nekona.png');
        }

        .character-notia .chat-user-avatar {
            background-image: url('profile-pic/notia-pf.png');
        }

        .character-ququ .chat-user-avatar {
            background-image: url('profile-pic/ququ-pf.png');
        }

        .character-rainy .chat-user-avatar {
            background-image: url('profile-pic/rainy-pf.png');
        }

        .character-rindo .chat-user-avatar {
            background-image: url('profile-pic/rindo-pf.png');
        }

        .character-sikirei .chat-user-avatar {
            background-image: url('profile-pic/sikirei-pf.png');
        }

        .character-vivi .chat-user-avatar {
            background-image: url('profile-pic/vivi-pf.png');
        }

        .character-wolf .chat-user-avatar {
            background-image: url('profile-pic/wolf.png');
        }

        .character-wolferia .chat-user-avatar {
            background-image: url('profile-pic/wolferia-pf.png');
        }

        .character-yawl .chat-user-avatar {
            background-image: url('profile-pic/yawl-pf.png');
        }

        .character-yuu .chat-user-avatar {
            background-image: url('profile-pic/yuu yii-pf.png');
        }

        .character-zwei .chat-user-avatar {
            background-image: url('profile-pic/zwei-pf.png');
        }

        @keyframes avatarFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        /* Avatar glow effect */
        .chat-user-avatar::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: linear-gradient(45deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            animation: haloRotate 6s linear infinite;
        }

        @keyframes haloRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .chat-user-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-user-name {
            color: white;
            font-size: 18px;
            font-weight: 700;
            margin: 0;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
        }

        /* Small decoration before character name */
        .chat-user-name::before {
            content: '💕';
            margin-right: 6px;
            font-size: 14px;
            animation: heartBeat 2s ease-in-out infinite;
        }

        @keyframes heartBeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .chat-user-status {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            margin: 0;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Status indicator */
        .chat-user-status::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4AE54A;
            box-shadow: 
                0 0 0 2px rgba(74, 229, 74, 0.3),
                0 0 8px rgba(74, 229, 74, 0.6);
            animation: onlinePulse 2s ease-in-out infinite;
        }

        @keyframes onlinePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Cute action buttons */
        .chat-actions {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 2;
        }

        .chat-action-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.25) 0%, 
                rgba(255, 255, 255, 0.1) 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        /* Button light effects */
        .chat-action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.4), 
                transparent);
            transition: left 0.6s;
        }

        .chat-action-btn:hover {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.35) 0%, 
                rgba(255, 255, 255, 0.2) 100%);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 8px 25px rgba(255, 182, 193, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .chat-action-btn:hover::before {
            left: 100%;
        }

        .chat-action-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Special effects: button decorations */
        .chat-action-btn:nth-child(1) {
            animation-delay: 0.1s;
        }
        .chat-action-btn:nth-child(2) {
            animation-delay: 0.2s;
        }
        .chat-action-btn:nth-child(3) {
            animation-delay: 0.3s;
        }

        /* Chat message area */
        .chat-window-messages {
            height: 585px;
            padding: 26px 20px;
            overflow-y: auto;
            background: #F5F3F0;
        }

        .chat-window-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-window-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .chat-window-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* Old .message-bubble styles removed - using ElizaOS .message structure instead */

        /* ElizaOS Message Structure Bubble Styling */
        .message {
            margin-bottom: 18px;
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
        }
        
        .message.user-message {
            justify-content: flex-end;
        }
        
        .message.ai-message {
            justify-content: flex-start;
            position: relative;
            padding-left: 54px;
        }
        
        /* Character avatars for ElizaOS messages */
        .message.ai-message::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #FFD700;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }
        
        .character-fliza .message.ai-message::before {
            background-image: url('profile-pic/fliza-pf.png');
        }
        
        .character-alice .message.ai-message::before {
            background-image: url('profile-pic/alice-pf.png');
        }
        
        .character-ash .message.ai-message::before {
            background-image: url('profile-pic/ash-pf.png');
        }
        
        .character-bobo .message.ai-message::before {
            background-image: url('profile-pic/bobo-pf.png');
        }
        
        .character-elinyaa .message.ai-message::before {
            background-image: url('profile-pic/elinyaa-pf.png');
        }
        
        .character-imeris .message.ai-message::before {
            background-image: url('profile-pic/imeris-pf.png');
        }
        
        .character-kyoko .message.ai-message::before {
            background-image: url('profile-pic/kyoko-pf.png');
        }
        
        .character-lena .message.ai-message::before {
            background-image: url('profile-pic/lena-pf.png');
        }
        
        .character-lilium .message.ai-message::before {
            background-image: url('profile-pic/lilium.png');
        }
        
        .character-maple .message.ai-message::before {
            background-image: url('profile-pic/maple-pf.png');
        }
        
        .character-miru .message.ai-message::before {
            background-image: url('profile-pic/Miru-pf.png');
        }
        
        .character-miumiu .message.ai-message::before {
            background-image: url('profile-pic/miumiu-pf.png');
        }
        
        .character-neco .message.ai-message::before {
            background-image: url('profile-pic/neco-pf.png');
        }
        
        .character-nekona .message.ai-message::before {
            background-image: url('profile-pic/nekona.png');
        }
        
        .character-notia .message.ai-message::before {
            background-image: url('profile-pic/notia-pf.png');
        }
        
        .character-ququ .message.ai-message::before {
            background-image: url('profile-pic/ququ-pf.png');
        }
        
        .character-rainy .message.ai-message::before {
            background-image: url('profile-pic/rainy-pf.png');
        }
        
        .character-rindo .message.ai-message::before {
            background-image: url('profile-pic/rindo-pf.png');
        }
        
        .character-sikirei .message.ai-message::before {
            background-image: url('profile-pic/sikirei-pf.png');
        }
        
        .character-vivi .message.ai-message::before {
            background-image: url('profile-pic/vivi-pf.png');
        }
        
        .character-wolf .message.ai-message::before {
            background-image: url('profile-pic/wolf.png');
        }
        
        .character-wolferia .message.ai-message::before {
            background-image: url('profile-pic/wolferia-pf.png');
        }
        
        .character-yawl .message.ai-message::before {
            background-image: url('profile-pic/yawl-pf.png');
        }
        
        .character-yuu .message.ai-message::before {
            background-image: url('profile-pic/yuu yii-pf.png');
        }
        
        .character-zwei .message.ai-message::before {
            background-image: url('profile-pic/zwei-pf.png');
        }
        
        .message-content {
            max-width: 80%;
            position: relative;
        }
        
        .message.ai-message .message-text {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                        0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
            display: block !important;
        }
        
        .message.ai-message .message-text::after {
            content: '';
            position: absolute;
            bottom: 0px;
            left: -8px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 12px 12px 0;
            border-color: transparent #FF8A50 transparent transparent;
        }
        
        .message.ai-message .message-time {
            background: none !important;
            border-radius: none !important;
            padding: 0 !important;
            font-size: 12px !important;
            color: rgba(0, 0, 0, 0.7) !important;
            font-weight: bold !important;
            display: block !important;
            margin-bottom: 0 !important;
        }
        
        .message.user-message .message-text {
            background: linear-gradient(135deg, #F0F0F0 0%, #E0E0E0 50%, #D0D0D0 100%) !important;
            color: #333 !important;
            border-radius: 20px 20px 5px 20px !important;
            padding: 16px 20px !important;
            font-size: 18px !important;
            box-shadow: 0 4px 12px rgba(224, 224, 224, 0.4),
                        0 2px 6px rgba(0, 0, 0, 0.1) !important;
        }
        
        .message.user-message .message-time {
            background: transparent !important;
            color: #333 !important;
            border-radius: none !important;
            padding: 0 !important;
            font-size: 12px !important;
            font-weight: normal !important;
        }


        #chat-window-messages .message-bubble.ai .bubble-header,
        .chat-window-messages .message-bubble.ai .bubble-header,
        .message-bubble.ai .bubble-header,
        .bubble-header {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 182, 193, 0.9)) !important;
            border-radius: 15px 15px 0 0 !important;
            padding: 6px 12px !important;
            font-size: 12px !important;
            color: rgba(0, 0, 0, 0.7) !important;
            font-weight: bold !important;
            display: flex !important;
            align-items: center !important;
            justify-content: space-between !important;
        }

        #chat-window-messages .message-bubble.ai .bubble-content,
        .chat-window-messages .message-bubble.ai .bubble-content,
        .message-bubble.ai .bubble-content {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 8px 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                        0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
            display: block !important;
        }
        
        .chat-window-messages .bubble-content,
        .bubble-content {
            background: linear-gradient(135deg, #FFB084 0%, #FF9D6B 50%, #FF8A50 100%) !important;
            border-radius: 20px 20px 20px 5px !important;
            padding: 16px 20px !important;
            color: white !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
            position: relative !important;
            max-width: 300px !important;
            word-wrap: break-word !important;
            margin: 8px 0 !important;
            box-shadow: 0 4px 12px rgba(255, 157, 107, 0.3),
                        0 2px 6px rgba(139, 69, 19, 0.2) !important;
            border: none !important;
            text-shadow: 0 1px 2px rgba(139, 69, 19, 0.3) !important;
        }
        
        .message-bubble.ai .bubble-content::after {
            content: '';
            position: absolute;
            bottom: 0px;
            left: -8px;
            width: 0;
            height: 0;
            border-right: 12px solid #FF9D6B;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            filter: drop-shadow(-2px 2px 4px rgba(139, 69, 19, 0.15));
        }

        .message-bubble.user .bubble-header {
            background: #E0E0E0;
            color: #333;
        }

        .message-bubble.user .bubble-content {
            background: linear-gradient(135deg, #F0F0F0 0%, #E0E0E0 50%, #D0D0D0 100%);
            color: #333;
            border-radius: 20px 20px 5px 20px;
            box-shadow: 0 4px 12px rgba(224, 224, 224, 0.4),
                        0 2px 6px rgba(0, 0, 0, 0.1);
        }
        
        .message-bubble.user .bubble-content::after {
            content: '';
            position: absolute;
            bottom: 0px;
            right: -8px;
            width: 0;
            height: 0;
            border-left: 12px solid #E0E0E0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.1));
        }


        .bubble-controls {
            display: flex;
            gap: 4px;
        }

        .bubble-control {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Chat input area - minimalist style */
        .chat-window-input {
            padding: 12px 16px 16px;
            background: linear-gradient(180deg, #FAFAFA 0%, #F5F5F5 100%);
            border-radius: 0 0 23px 23px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            cursor: auto;
        }

        .chat-window-messages {
            cursor: auto;
        }

        .input-container {
            display: flex;
            background: white;
            border-radius: 24px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            overflow: hidden;
            align-items: center;
            padding: 4px 4px 4px 16px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .input-container:focus-within {
            border-color: rgba(255, 182, 193, 0.5);
            box-shadow: 0 0 0 3px rgba(255, 182, 193, 0.1),
                        0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .chat-input-field {
            flex: 1;
            padding: 10px 0;
            border: none;
            background: transparent;
            font-size: 16px;
            outline: none;
            color: #333;
            line-height: 1.5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
        }

        .chat-input-field::placeholder {
            color: rgba(0, 0, 0, 0.35);
            font-size: 15px;
        }
        
        .chat-input-field:focus {
            background: transparent;
        }

        /* Send button - minimal paper plane style */
        .send-btn {
            background: linear-gradient(135deg, #667EEA 0%, #764BA2 100%);
            border: none;
            padding: 0;
            color: white;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .send-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.3s ease;
        }

        .send-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .send-btn:hover::before {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .send-btn:active {
            transform: translateY(0) scale(0.96);
        }

        /* Send animation effects */
        .send-btn.sending {
            animation: paperPlane 0.6s ease-out;
        }

        @keyframes paperPlane {
            0% {
                transform: translateY(-1px) scale(1);
            }
            50% {
                transform: translateY(-3px) scale(1.1) rotate(10deg);
            }
            100% {
                transform: translateY(-1px) scale(1) rotate(0deg);
            }
        }

        .send-btn.sending svg {
            animation: planeFly 0.6s ease-out;
        }

        @keyframes planeFly {
            0% {
                transform: translateX(0) rotate(0deg);
            }
            50% {
                transform: translateX(2px) rotate(15deg);
            }
            100% {
                transform: translateX(0) rotate(0deg);
            }
        }

        /* Additional function button area (optional) */
        .input-extras {
            display: flex;
            gap: 8px;
            margin-right: 8px;
            align-items: center;
        }

        .input-extra-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .input-extra-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            color: rgba(0, 0, 0, 0.7);
        }

        /* Animation effects */
        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .floating-chat {
                width: 800px;
                height: 700px;
                right: -170px;
                scale: 0.5;
                top: -152px;
            }
            
            .chat-window-messages {
                height: 495px;
            }
        }

        @media (max-width: 768px) {
            .floating-chat {
                bottom: 30px;
                left: -105px;
                right: 0px;
                width: 160vw;
                height: 365dvh;
                border-radius: -10px;
                border-width: -15px;
                transform: none;
            }

            .chat-window-header { cursor: default; }

            .chat-window-messages {
                height: calc(100dvh - 140px); /* header + input approx */
            }

            .music-controls { display: none; }
        }

        /* Mobile Portrait Layout - UI Optimization */
        @media (max-width: 768px) and (orientation: portrait) {
            /* Floating Chat - Transparent glass effect for portrait */
            .floating-chat {
                background: rgba(255, 255, 255, 0.1) !important;
                backdrop-filter: blur(20px) saturate(180%) !important;
                -webkit-backdrop-filter: blur(20px) saturate(180%) !important;
                border: 1px solid rgba(255, 255, 255, 0.2) !important;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
            }

            /* Chat Messages Area - Transparent glass effect */
            .chat-window-messages {
                background: rgba(255, 255, 255, 0.05) !important;
                backdrop-filter: blur(15px) saturate(160%) !important;
                -webkit-backdrop-filter: blur(15px) saturate(160%) !important;
                border: 1px solid rgba(255, 255, 255, 0.1) !important;
                border-radius: 12px !important;
            }

            /* Chat Input Area - Transparent glass effect */
            .chat-window-input {
                background: rgba(255, 255, 255, 0.05) !important;
                backdrop-filter: blur(15px) saturate(160%) !important;
                -webkit-backdrop-filter: blur(15px) saturate(160%) !important;
                border: 1px solid rgba(255, 255, 255, 0.1) !important;
                border-radius: 12px !important;
            }

            /* Language Toggle - Top left corner for portrait */
            .language-toggle {
                top: 15px !important;
                left: 15px !important;
                bottom: auto !important;
                padding: 6px 10px !important;
                font-size: 10px !important;
                scale: 0.5 !important;
            }

            /* Wallet Status Info - More compact for portrait */
            .wallet-status-info {
                top: 15px !important;
                right: 15px !important;
                padding: 6px 10px !important;
                font-size: 10px !important;
                scale: 0.5 !important;
            }

            /* Music Controls - Show in portrait with custom positioning */
            .music-controls {
                display: block !important;
                position: fixed !important;
                top: 60px !important;
                right: 15px !important;
                width: 200px !important;
                height: 80px !important;
                scale: 0.7 !important;
                z-index: 1050 !important;
            }

            /* Left Panel - Minimize for portrait */
            .left-panel {
                left: 10px !important;
                bottom: 10px !important;
                transform: scale(0.8) !important;
                transform-origin: bottom left !important;
            }

            /* Voice Play Button - Smaller for mobile */
            .voice-play-btn {
                padding: 3px 6px !important;
                font-size: 10px !important;
                margin-top: 3px !important;
                margin-left: 3px !important;
            }
        }

        /* Mobile Landscape Layout - Additional Elements */
        @media (orientation: landscape) and (max-width: 1200px) and (max-height: 500px) {
            /* Music Controls - Proper landscape scaling without breaking layout */
            .music-controls {
                width: 280px !important; /* Keep original width */
                height: 120px !important; /* Keep original height */
                top: 15px !important;
                left: 15px !important;
                padding: 15px !important; /* Keep original padding */
                transform: scale(0.75) !important; /* Only scale the entire container */
                transform-origin: top left !important;
            }
            
            /* Don't override internal elements - let them scale naturally with container */
            
            /* Language Toggle - Compact for landscape */
            .language-toggle {
                bottom: 15px !important;
                left: 15px !important;
                padding: 5px 8px !important;
                font-size: 10px !important;
                transform: scale(0.7) !important;
                transform-origin: bottom left !important;
            }
            
            .language-btn {
                padding: 3px 6px !important;
                font-size: 9px !important;
            }
            
            /* Wallet Status Info - Hide or minimize in landscape */
            .wallet-status-info {
                display: none !important;
            }
        }


        /* VRM status information */
        .vrm-status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
            font-size: 14px;
            z-index: 10;
        }

        /* Hide voice/TTS playing notifications */
        [data-playing-status],
        .playing-indicator,
        .tts-status,
        .voice-status,
        .audio-playing-indicator,
        .speech-playing,
        #playing-indicator,
        #tts-playing,
        #voice-playing,
        .playing-notification {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }

        /* Hide any element containing "Playing" text in top-right area */
        div[style*="position: fixed"][style*="top"][style*="right"]:contains("Playing"),
        div[style*="position: absolute"][style*="top"][style*="right"]:contains("Playing") {
            display: none !important;
        }

        /* Left control panel */
        .left-panel {
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section h4 {
            color: #ffeaa7;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }

        .emotion-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }

        .emotion-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .emotion-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .emotion-btn.active {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        #character-selector, #animation-selector {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }

        .play-animation-btn {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .play-animation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(116, 185, 255, 0.4);
        }

        /* Mobile Optimization Notice Modal - Game Style */
        .mobile-notice-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .mobile-notice-modal {
            background: #f4d03f;
            border: 6px solid #2d1b3d;
            border-radius: 20px;
            padding: 0;
            max-width: 320px;
            width: 90%;
            position: relative;
            animation: modalBounceIn 0.5s ease-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .mobile-notice-header {
            background: linear-gradient(135deg, #2d1b3d 0%, #4a2c5a 100%);
            color: #f4d03f;
            padding: 15px 20px;
            border-radius: 14px 14px 0 0;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 3px solid #f4d03f;
            border-bottom: none;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
        }

        .mobile-notice-content {
            padding: 20px;
            color: #2d1b3d;
            font-size: 14px;
            line-height: 1.6;
            text-align: center;
            font-weight: 600;
        }

        .mobile-notice-close {
            background: linear-gradient(135deg, #2d1b3d 0%, #4a2c5a 100%);
            color: #f4d03f;
            border: 3px solid #2d1b3d;
            border-radius: 15px;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px auto 0;
            display: block;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 0px #1a0f1f, 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .mobile-notice-close:hover {
            background: linear-gradient(135deg, #4a2c5a 0%, #6c4a7a 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 0px #1a0f1f, 0 8px 15px rgba(0, 0, 0, 0.4);
        }

        .mobile-notice-close:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0px #1a0f1f, 0 3px 5px rgba(0, 0, 0, 0.3);
        }

        @keyframes modalBounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(-50px);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(0);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Show mobile notice only on mobile devices */
        @media (max-width: 768px) {
            .mobile-notice-overlay.show {
                display: flex;
            }
        }
    </style>
</head>

<body>
    <!-- Mobile Optimization Notice Modal -->
    <div class="mobile-notice-overlay" id="mobile-notice-overlay">
        <div class="mobile-notice-modal">
            <div class="mobile-notice-header">
                MOBILE NOTICE
            </div>
            <div class="mobile-notice-content">
                The mobile experience is currently being optimized and requires a DApp browser for full functionality. 
                <br><br>
                <strong>We recommend using desktop for the best experience.</strong>
            </div>
            <button class="mobile-notice-close" onclick="closeMobileNotice()">CLOSE</button>
        </div>
    </div>

    <!-- Include chat system - AI integration handled by ElizaOS -->
    <script type="module" src="chat-system-eliza.js"></script>
    
    <!-- Mobile Notice Modal JavaScript -->
    <script>
        // Mobile Notice Modal Functions
        window.showMobileNotice = function() {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay && window.innerWidth <= 768) {
                overlay.classList.add('show');
            }
        }

        window.closeMobileNotice = function() {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Remember user closed the notice (optional - store in sessionStorage)
                sessionStorage.setItem('mobileNoticeShown', 'true');
            }
        }

        // Show mobile notice on page load for mobile devices
        window.addEventListener('load', () => {
            // Check if notice was already shown in this session
            const noticeShown = sessionStorage.getItem('mobileNoticeShown');
            if (!noticeShown && window.innerWidth <= 768) {
                // Delay showing notice for better UX after page loads
                setTimeout(window.showMobileNotice, 2000);
            }
        });

        // Handle window resize to show/hide notice appropriately
        window.addEventListener('resize', () => {
            const overlay = document.getElementById('mobile-notice-overlay');
            if (overlay && window.innerWidth > 768) {
                overlay.classList.remove('show');
            }
        });
    </script>
    <div class="game-container">
        <!-- Left VRM display area -->
        <div class="vrm-container">
            <canvas id="vrm-canvas" class="vrm-canvas"></canvas>
            
            <!-- AI speech bubble -->
            <div class="ai-speech-bubble" id="ai-speech-bubble" style="display: none;"></div>

            <!-- VRM status info -->
            <div class="vrm-status" id="vrm-status" style="display: none;">
                <div>🎭 VRM Status: <span id="vrm-loaded" data-i18n="status.loading">Loading...</span></div>
                <div>🎬 Current Animation: <span id="current-animation" data-i18n="status.none">None</span></div>
                <div>😊 Expression: <span id="current-expression" data-i18n="status.neutral">Neutral</span></div>
                <div>🎵 Auto Blink: <span id="auto-blinking" data-i18n="status.enabled">Enabled</span></div>
            </div>


            <!-- Retro music player -->
            <div class="music-controls" id="music-controls">
                <div class="music-window-title">
                    Background Music
                    <div class="window-controls">
                        <button class="window-btn minimize-btn"></button>
                        <button class="window-btn maximize-btn"></button>
                        <button class="window-btn close-btn"></button>
                    </div>
                </div>
                <div class="music-player-content">
                    <div class="music-controls-row">
                        <button class="music-control-btn">⏮</button>
                        <button class="music-control-btn play-btn" id="music-toggle" onclick="toggleMusic()">▶</button>
                        <button class="music-control-btn">⏭</button>
                    </div>
                    <div class="volume-control">
                        <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="50"
                            onchange="adjustVolume(this.value)">
                        <span class="volume-label" id="volume-label">50</span>
                    </div>
                </div>
            </div>

            <!-- Language switcher -->
            <div class="language-toggle" id="language-toggle">
                <span data-i18n="char.select.language">Language: </span>
                <button class="language-btn" id="lang-en" onclick="switchLanguage('en')">EN</button>
                <button class="language-btn" id="lang-zh" onclick="switchLanguage('zh')">ZH</button>
            </div>
            

            <!-- Background music element -->
            <audio id="background-music" loop preload="auto" controls style="display: none;">
                <source src="BG/bgm-compressed.mp3" type="audio/mpeg">
                Your browser does not support audio playback.
            </audio>
            
            <!-- Wallet status (visible when logged in) -->
            <div class="wallet-status-info" id="wallet-status-info" style="display: none;">
                <div class="wallet-avatar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 21 21">
                        <g fill="none" fill-rule="evenodd" transform="translate(3 4)">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M.5 2.5h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2zm1-2h9a1 1 0 0 1 1 1v1H.5v-1a1 1 0 0 1 1-1z"/>
                            <circle cx="11.5" cy="7.5" r="1" fill="currentColor"/>
                        </g>
                    </svg>
                </div>
                <span class="wallet-address" id="wallet-address">Connecting...</span>
                <button class="wallet-disconnect" onclick="disconnectWallet()">Logout</button>
            </div>

        </div>

        <!-- Left control panel removed -->

        <!-- Wallet status -->
        <div class="wallet-status" id="wallet-status" style="display: none;">
            <span>Wallet:</span>
            <span class="wallet-address" id="wallet-address"></span>
            <button class="wallet-disconnect" onclick="disconnectWallet()">Disconnect</button>
        </div>



        <!-- Floating chat window -->
        <div class="floating-chat" id="floating-chat">
            <!-- Mobile top bar styled chat header -->
            <div class="chat-window-header">
                <!-- Real phone status bar -->
                <div class="phone-status-bar">
                    <div class="status-left">
                        <div class="carrier-info">
                            <svg width="18" height="12" viewBox="0 0 18 12" fill="currentColor">
                                <rect x="0" y="8" width="2" height="4" rx="0.5"/>
                                <rect x="4" y="6" width="2" height="6" rx="0.5"/>
                                <rect x="8" y="4" width="2" height="8" rx="0.5"/>
                                <rect x="12" y="2" width="2" height="10" rx="0.5"/>
                            </svg>
                            <span>docomo</span>
                        </div>
                        <span class="network-type">4G</span>
                    </div>
                    <div class="status-center">
                        <div class="time-display" id="phone-time">1:26</div>
                    </div>
                    <div class="status-right">
                        <span class="status-icon">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z"/>
                            </svg>
                        </span>
                        <span class="status-icon">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M17.81,4.47C17.73,4.47 17.65,4.45 17.58,4.41C15.66,3.42 14,3.42 12.34,4.41C12.26,4.45 12.18,4.47 12.1,4.47C12,4.47 11.93,4.45 11.85,4.41C9.93,3.42 8.27,3.42 6.61,4.41C6.54,4.45 6.46,4.47 6.38,4.47C6.28,4.47 6.21,4.45 6.13,4.41L5.5,4.1C5.32,4 5.1,4.08 5,4.26C4.92,4.44 5,4.66 5.18,4.76L5.81,5.07C5.89,5.11 5.97,5.13 6.05,5.13C6.15,5.13 6.22,5.11 6.3,5.07C7.92,4.08 9.58,4.08 11.2,5.07C11.28,5.11 11.36,5.13 11.44,5.13C11.54,5.13 11.61,5.11 11.69,5.07C13.31,4.08 14.97,4.08 16.59,5.07C16.67,5.11 16.75,5.13 16.83,5.13C16.93,5.13 17,5.11 17.08,5.07L17.71,4.76C17.89,4.66 17.97,4.44 17.89,4.26C17.81,4.08 17.59,4 17.41,4.1L17.81,4.47Z"/>
                            </svg>
                        </span>
                        <span class="status-icon">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M14,20A2,2 0 0,1 12,22A2,2 0 0,1 10,20H14M12,2A7,7 0 0,1 19,9C19,11.38 17.81,13.47 16,14.74V17A1,1 0 0,1 15,18H9A1,1 0 0,1 8,17V14.74C6.19,13.47 5,11.38 5,9A7,7 0 0,1 12,2M9,21H15A1,1 0 0,1 15,22H9A1,1 0 0,1 9,21Z"/>
                            </svg>
                        </span>
                        <span class="battery-percentage">79%</span>
                        <span class="status-icon">
                            <svg width="22" height="12" viewBox="0 0 24 12" fill="none">
                                <rect x="1" y="2" width="20" height="8" rx="2" stroke="currentColor" stroke-width="1"/>
                                <rect x="2.5" y="3.5" width="16" height="5" rx="1" fill="currentColor"/>
                                <rect x="22" y="5" width="2" height="2" rx="0.5" fill="currentColor"/>
                            </svg>
                        </span>
                    </div>
                </div>
                
                <!-- Anime-style chat title area -->
                <div class="chat-title-area">
                    <div class="chat-user-info">
                        <div class="chat-user-avatar"></div>
                        <div class="chat-user-details">
                            <h3 class="chat-user-name" id="character-name">Alice</h3>
                            <p class="chat-user-status" data-i18n="status.online">Online</p>
                        </div>
                    </div>
                    <div class="chat-actions">
                        <button class="chat-action-btn" title="发送照片">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19M21,19H5V5H19V19Z"/>
                                <circle cx="9" cy="9" r="2"/>
                                <path d="M21,15L18,12L15,15L13,13L5,21H19A2,2 0 0,0 21,19V15Z"/>
                            </svg>
                        </button>
                        <button class="chat-action-btn" title="发送表情">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12,2C13.1,2 14,2.9 14,4C14,5.1 13.1,6 12,6C10.9,6 10,5.1 10,4C10,2.9 10.9,2 12,2M21,9V7L15,1H5C3.89,1 3,1.89 3,3V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V9M19,19H5V19L5,3H13V9H19V19Z"/>
                                <circle cx="12" cy="12" r="1.5"/>
                                <circle cx="8" cy="10" r="1"/>
                                <circle cx="16" cy="10" r="1"/>
                                <path d="M8.5,14.5C9.5,16.5 14.5,16.5 15.5,14.5"/>
                            </svg>
                        </button>
                        <button class="chat-action-btn" title="心情设定">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5 2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"/>
                                <circle cx="12" cy="8.5" r="1.5" fill="white"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Chat message area -->
            <div class="chat-window-messages" id="chat-window-messages">
                <!-- Messages will be dynamically added here -->
                <div style="display: none;">
                    <span id="character-name">芙莉莎</span>
                </div>
            </div>

            <!-- Chat input area -->
            <div class="chat-window-input">
                <div class="input-container">
                    <input type="text" class="chat-input-field" id="chat-input-field" data-i18n-placeholder="chat.input.placeholder" placeholder="Type your message here..." onkeypress="handleChatKeyPress(event)">
                    <button class="send-btn" onclick="sendChatMessage()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2.01 21L23 12L2.01 3L2 10L17 12L2 14L2.01 21Z" fill="currentColor"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Unauthorized access notification -->
        <div class="unauthorized-overlay" id="unauthorized-overlay" style="display: none;">
            <div class="unauthorized-content">
                <h2 data-i18n="wallet.verification.title">🔒 Wallet Verification Required</h2>
                <p data-i18n="wallet.verification.message">Please connect your Solana wallet first to access the AI girlfriend chat room. Each wallet address will get a unique personalized experience!</p>
                <button class="connect-wallet-btn" onclick="redirectToCharacterSelect()" data-i18n="wallet.verification.button">
                    Back to Connect Wallet
                </button>
            </div>
        </div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
                "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2/lib/three-vrm.module.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Official Mixamo to VRM bone mapping
        const mixamoVRMRigMap = {
            mixamorigHips: 'hips',
            mixamorigSpine: 'spine',
            mixamorigSpine1: 'chest',
            mixamorigSpine2: 'upperChest',
            mixamorigNeck: 'neck',
            mixamorigHead: 'head',
            mixamorigLeftShoulder: 'leftShoulder',
            mixamorigLeftArm: 'leftUpperArm',
            mixamorigLeftForeArm: 'leftLowerArm',
            mixamorigLeftHand: 'leftHand',
            mixamorigLeftHandThumb1: 'leftThumbMetacarpal',
            mixamorigLeftHandThumb2: 'leftThumbProximal',
            mixamorigLeftHandThumb3: 'leftThumbDistal',
            mixamorigLeftHandIndex1: 'leftIndexProximal',
            mixamorigLeftHandIndex2: 'leftIndexIntermediate',
            mixamorigLeftHandIndex3: 'leftIndexDistal',
            mixamorigLeftHandMiddle1: 'leftMiddleProximal',
            mixamorigLeftHandMiddle2: 'leftMiddleIntermediate',
            mixamorigLeftHandMiddle3: 'leftMiddleDistal',
            mixamorigLeftHandRing1: 'leftRingProximal',
            mixamorigLeftHandRing2: 'leftRingIntermediate',
            mixamorigLeftHandRing3: 'leftRingDistal',
            mixamorigLeftHandPinky1: 'leftLittleProximal',
            mixamorigLeftHandPinky2: 'leftLittleIntermediate',
            mixamorigLeftHandPinky3: 'leftLittleDistal',
            mixamorigRightShoulder: 'rightShoulder',
            mixamorigRightArm: 'rightUpperArm',
            mixamorigRightForeArm: 'rightLowerArm',
            mixamorigRightHand: 'rightHand',
            mixamorigRightHandPinky1: 'rightLittleProximal',
            mixamorigRightHandPinky2: 'rightLittleIntermediate',
            mixamorigRightHandPinky3: 'rightLittleDistal',
            mixamorigRightHandRing1: 'rightRingProximal',
            mixamorigRightHandRing2: 'rightRingIntermediate',
            mixamorigRightHandRing3: 'rightRingDistal',
            mixamorigRightHandMiddle1: 'rightMiddleProximal',
            mixamorigRightHandMiddle2: 'rightMiddleIntermediate',
            mixamorigRightHandMiddle3: 'rightMiddleDistal',
            mixamorigRightHandIndex1: 'rightIndexProximal',
            mixamorigRightHandIndex2: 'rightIndexIntermediate',
            mixamorigRightHandIndex3: 'rightIndexDistal',
            mixamorigRightHandThumb1: 'rightThumbMetacarpal',
            mixamorigRightHandThumb2: 'rightThumbProximal',
            mixamorigRightHandThumb3: 'rightThumbDistal',
            mixamorigLeftUpLeg: 'leftUpperLeg',
            mixamorigLeftLeg: 'leftLowerLeg',
            mixamorigLeftFoot: 'leftFoot',
            mixamorigLeftToeBase: 'leftToes',
            mixamorigRightUpLeg: 'rightUpperLeg',
            mixamorigRightLeg: 'rightLowerLeg',
            mixamorigRightFoot: 'rightFoot',
            mixamorigRightToeBase: 'rightToes',
        };

        // ActorCore to VRM bone mapping
        const actorCoreVRMRigMap = {
            CC_Base_Hip: 'hips',
            CC_Base_Waist: 'spine',
            CC_Base_Spine01: 'chest',
            CC_Base_Spine02: 'upperChest',
            CC_Base_NeckTwist01: 'neck',
            CC_Base_Head: 'head',
            CC_Base_L_Clavicle: 'leftShoulder',
            CC_Base_L_Upperarm: 'leftUpperArm',
            CC_Base_L_Forearm: 'leftLowerArm',
            CC_Base_L_Hand: 'leftHand',
            CC_Base_L_Thumb1: 'leftThumbMetacarpal',
            CC_Base_L_Thumb2: 'leftThumbProximal',
            CC_Base_L_Thumb3: 'leftThumbDistal',
            CC_Base_L_Index1: 'leftIndexProximal',
            CC_Base_L_Index2: 'leftIndexIntermediate',
            CC_Base_L_Index3: 'leftIndexDistal',
            CC_Base_L_Mid1: 'leftMiddleProximal',
            CC_Base_L_Mid2: 'leftMiddleIntermediate',
            CC_Base_L_Mid3: 'leftMiddleDistal',
            CC_Base_L_Ring1: 'leftRingProximal',
            CC_Base_L_Ring2: 'leftRingIntermediate',
            CC_Base_L_Ring3: 'leftRingDistal',
            CC_Base_L_Pinky1: 'leftLittleProximal',
            CC_Base_L_Pinky2: 'leftLittleIntermediate',
            CC_Base_L_Pinky3: 'leftLittleDistal',
            CC_Base_R_Clavicle: 'rightShoulder',
            CC_Base_R_Upperarm: 'rightUpperArm',
            CC_Base_R_Forearm: 'rightLowerArm',
            CC_Base_R_Hand: 'rightHand',
            CC_Base_R_Pinky1: 'rightLittleProximal',
            CC_Base_R_Pinky2: 'rightLittleIntermediate',
            CC_Base_R_Pinky3: 'rightLittleDistal',
            CC_Base_R_Ring1: 'rightRingProximal',
            CC_Base_R_Ring2: 'rightRingIntermediate',
            CC_Base_R_Ring3: 'rightRingDistal',
            CC_Base_R_Mid1: 'rightMiddleProximal',
            CC_Base_R_Mid2: 'rightMiddleIntermediate',
            CC_Base_R_Mid3: 'rightMiddleDistal',
            CC_Base_R_Index1: 'rightIndexProximal',
            CC_Base_R_Index2: 'rightIndexIntermediate',
            CC_Base_R_Index3: 'rightIndexDistal',
            CC_Base_R_Thumb1: 'rightThumbMetacarpal',
            CC_Base_R_Thumb2: 'rightThumbProximal',
            CC_Base_R_Thumb3: 'rightThumbDistal',
            CC_Base_L_Thigh: 'leftUpperLeg',
            CC_Base_L_Calf: 'leftLowerLeg',
            CC_Base_L_Foot: 'leftFoot',
            CC_Base_L_ToeBase: 'leftToes',
            CC_Base_R_Thigh: 'rightUpperLeg',
            CC_Base_R_Calf: 'rightLowerLeg',
            CC_Base_R_Foot: 'rightFoot',
            CC_Base_R_ToeBase: 'rightToes',
        };

        // Complete animation mapping - includes all Mixamo and ActorCore animations
        const animationMap = {
            // Idle animations
            'Breathing Idle': 'mixamo animation/Breathing Idle.fbx',
            'Happy Idle': 'mixamo animation/Happy Idle.fbx',
            // Mixamo animation
            'Acknowledging': 'mixamo animation/Acknowledging.fbx',
            'Agreeing': 'mixamo animation/Agreeing.fbx',
            'Agreeing 2': 'mixamo animation/Agreeing 2.fbx',
            'Angry': 'mixamo animation/Angry.fbx',
            'Bashful': 'mixamo animation/Bashful.fbx',
            'Blow A Kiss': 'mixamo animation/Blow A Kiss.fbx',
            'Cheering': 'mixamo animation/Cheering.fbx',
            'Clapping': 'mixamo animation/Clapping.fbx',
            'Crying': 'mixamo animation/Crying.fbx',
            'Gangnam Style': 'mixamo animation/Gangnam Style.fbx',
            'Happy': 'mixamo animation/Happy.fbx',
            'Hard Head Nod': 'mixamo animation/Hard Head Nod.fbx',
            'Hip Hop Dancing': 'mixamo animation/Hip Hop Dancing.fbx',
            'Hip Hop Dancing 2': 'mixamo animation/Hip Hop Dancing 2.fbx',
            'Joyful Jump': 'mixamo animation/Joyful Jump.fbx',
            'Looking': 'mixamo animation/Looking.fbx',
            'Rejected': 'mixamo animation/Rejected.fbx',
            'Rumba Dancing': 'mixamo animation/Rumba Dancing.fbx',
            'Salute': 'mixamo animation/Salute.fbx',
            'Spin In Place': 'mixamo animation/Spin In Place.fbx',
            'Standing Greeting 2': 'mixamo animation/Standing Greeting 2.fbx',
            'Surprised': 'mixamo animation/Surprised.fbx',
            'Thankful': 'mixamo animation/Thankful.fbx',
            'Thinking': 'mixamo animation/Thinking.fbx',
            'Yawn': 'mixamo animation/Yawn.fbx',
            // ActorCore animation
            'Stand Happy (ActorCore)': 'actorcore animation/stand-happy-f.fbx'
        };

        // Emotion mapping remains unchanged, used for AI auto-trigger
        const emotionAnimationMap = {
            happy: 'mixamo animation/Happy.fbx',
            sad: 'mixamo animation/Crying.fbx',
            angry: 'mixamo animation/Angry.fbx',
            surprised: 'mixamo animation/Surprised.fbx',
            thinking: 'mixamo animation/Thinking.fbx',
            greeting: 'mixamo animation/Standing Greeting 2.fbx',
            agreeing: 'mixamo animation/Agreeing.fbx',
            rejecting: 'mixamo animation/Rejected.fbx',
            clapping: 'mixamo animation/Clapping.fbx',
            cheering: 'mixamo animation/Cheering.fbx',
            thankful: 'mixamo animation/Thankful.fbx',
            bashful: 'mixamo animation/Bashful.fbx',
            neutral: 'mixamo animation/Breathing Idle.fbx',
            breathing: 'mixamo animation/Breathing Idle.fbx',
            kiss: 'mixamo animation/Blow A Kiss.fbx',
            dancing: 'mixamo animation/Hip Hop Dancing.fbx'
        };

        // Keyword emotion mapping
        const keywordEmotionMap = {
            // Happy related
            '开心': 'happy',
            '高兴': 'happy',
            '快乐': 'happy',
            '哈哈': 'happy',
            '笑': 'happy',
            '好棒': 'happy',
            '太好了': 'happy',
            '喜欢': 'happy',
            '爱': 'happy',
            '棒': 'cheering',

            // Sad related
            '伤心': 'sad',
            '难过': 'sad',
            '哭': 'sad',
            '痛苦': 'sad',
            '失望': 'sad',
            '沮丧': 'sad',

            // Angry related
            '生气': 'angry',
            '愤怒': 'angry',
            '讨厌': 'angry',
            '烦': 'angry',
            '气死了': 'angry',

            // Surprised related
            '惊讶': 'surprised',
            '震惊': 'surprised',
            '不敢相信': 'surprised',
            '天哪': 'surprised',
            '哇': 'surprised',

            // Thinking related
            '想': 'thinking',
            '思考': 'thinking',
            '考虑': 'thinking',
            '嗯': 'thinking',

            // Greeting related
            '你好': 'greeting',
            '嗨': 'greeting',
            '早上好': 'greeting',
            '晚上好': 'greeting',
            '再见': 'greeting',

            // Agreement related
            '好的': 'agreeing',
            '同意': 'agreeing',
            '是的': 'agreeing',
            '对': 'agreeing',
            '没错': 'agreeing',

            // Rejection related
            '不': 'rejecting',
            '不要': 'rejecting',
            '拒绝': 'rejecting',
            '不行': 'rejecting',

            // Thanks related
            '谢谢': 'thankful',
            '感谢': 'thankful',
            '谢': 'thankful',

            // Shy related
            '害羞': 'bashful',
            '不好意思': 'bashful',
            '脸红': 'bashful',

            // Kiss related
            '亲': 'kiss',
            '吻': 'kiss',
            '么么': 'kiss',

            // Dance related
            '跳舞': 'dancing',
            '舞蹈': 'dancing',
            '音乐': 'dancing'
        };

        // Official loadMixamoAnimation function
        function loadMixamoAnimation(url, vrm) {
            const loader = new FBXLoader();
            return loader.loadAsync(url).then((asset) => {
                const clip = THREE.AnimationClip.findByName(asset.animations, 'mixamo.com');

                if (!clip) {
                    throw new Error('找不到 Mixamo 动画data');
                }

                const tracks = [];
                const restRotationInverse = new THREE.Quaternion();
                const parentRestWorldRotation = new THREE.Quaternion();
                const _quatA = new THREE.Quaternion();
                const _vec3 = new THREE.Vector3();

                const motionHipsHeight = asset.getObjectByName('mixamorigHips').position.y;
                const vrmHipsHeight = vrm.humanoid.normalizedRestPose.hips.position[1];
                const hipsPositionScale = vrmHipsHeight / motionHipsHeight;

                clip.tracks.forEach((track) => {
                    const trackSplitted = track.name.split('.');
                    const mixamoRigName = trackSplitted[0];
                    const vrmBoneName = mixamoVRMRigMap[mixamoRigName];
                    const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                    const mixamoRigNode = asset.getObjectByName(mixamoRigName);

                    if (vrmNodeName != null) {
                        const propertyName = trackSplitted[1];

                        mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
                        mixamoRigNode.parent.getWorldQuaternion(parentRestWorldRotation);

                        if (track instanceof THREE.QuaternionKeyframeTrack) {
                            for (let i = 0; i < track.values.length; i += 4) {
                                const flatQuaternion = track.values.slice(i, i + 4);
                                _quatA.fromArray(flatQuaternion);

                                _quatA
                                    .premultiply(parentRestWorldRotation)
                                    .multiply(restRotationInverse);

                                _quatA.toArray(flatQuaternion);
                                flatQuaternion.forEach((v, index) => {
                                    track.values[index + i] = v;
                                });
                            }

                            tracks.push(
                                new THREE.QuaternionKeyframeTrack(
                                    `${vrmNodeName}.${propertyName}`,
                                    track.times,
                                    track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? -v : v)),
                                )
                            );

                        } else if (track instanceof THREE.VectorKeyframeTrack) {
                            const value = track.values.map((v, i) =>
                                (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? -v : v) * hipsPositionScale
                            );
                            tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                        }
                    }
                });

                return new THREE.AnimationClip('vrmAnimation', clip.duration, tracks);
            });
        }

        // ActorCore animation load function
        function loadActorCoreAnimation(url, vrm) {
            const loader = new FBXLoader();
            return loader.loadAsync(url).then((asset) => {
                // ActorCore animation usually the first one is the main animation
                const clip = asset.animations[0];

                if (!clip) {
                    throw new Error('找不到 ActorCore 动画data');
                }

                const tracks = [];
                const restRotationInverse = new THREE.Quaternion();
                const parentRestWorldRotation = new THREE.Quaternion();
                const _quatA = new THREE.Quaternion();
                const _vec3 = new THREE.Vector3();

                // Try to find ActorCore Hip bone to calculate scaling
                let motionHipsHeight = 100; // Default value
                const actorCoreHips = asset.getObjectByName('CC_Base_Hip');
                if (actorCoreHips) {
                    motionHipsHeight = actorCoreHips.position.y;
                }

                const vrmHipsHeight = vrm.humanoid.normalizedRestPose.hips.position[1];
                const hipsPositionScale = vrmHipsHeight / motionHipsHeight;

                // console.log(`🎬 ActorCore animation processing: ${clip.name}, track count: ${clip.tracks.length}`);

                clip.tracks.forEach((track) => {
                    const trackSplitted = track.name.split('.');
                    const actorCoreRigName = trackSplitted[0];
                    const vrmBoneName = actorCoreVRMRigMap[actorCoreRigName];
                    const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                    const actorCoreRigNode = asset.getObjectByName(actorCoreRigName);

                    if (vrmNodeName != null && actorCoreRigNode) {
                        const propertyName = trackSplitted[1];

                        actorCoreRigNode.getWorldQuaternion(restRotationInverse).invert();
                        actorCoreRigNode.parent.getWorldQuaternion(parentRestWorldRotation);

                        if (track instanceof THREE.QuaternionKeyframeTrack) {
                            for (let i = 0; i < track.values.length; i += 4) {
                                const flatQuaternion = track.values.slice(i, i + 4);
                                _quatA.fromArray(flatQuaternion);

                                _quatA
                                    .premultiply(parentRestWorldRotation)
                                    .multiply(restRotationInverse);

                                _quatA.toArray(flatQuaternion);
                                flatQuaternion.forEach((v, index) => {
                                    track.values[index + i] = v;
                                });
                            }

                            tracks.push(
                                new THREE.QuaternionKeyframeTrack(
                                    `${vrmNodeName}.${propertyName}`,
                                    track.times,
                                    track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? -v : v)),
                                )
                            );

                        } else if (track instanceof THREE.VectorKeyframeTrack) {
                            const value = track.values.map((v, i) =>
                                (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? -v : v) * hipsPositionScale
                            );
                            tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                        }
                    } else if (!vrmBoneName) {
                        (window.AppConfig?.debug?.warn || console.warn)(`Unmapped ActorCore rig: ${actorCoreRigName}`);
                    }
                });

                // console.log(`✅ ActorCore animation retargeting completed, generated track count: ${tracks.length}`);
                return new THREE.AnimationClip('actorCoreAnimation', clip.duration, tracks);
            });
        }

        // Scene setup
        const canvas = document.getElementById('vrm-canvas');
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: false  // Changed to false to ensure background is opaque
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.NoToneMapping;  // No tone mapping, preserve original colors
        renderer.toneMappingExposure = 1.0;  // Standard exposure
        renderer.outputColorSpace = THREE.SRGBColorSpace;  // Correct color space

        const camera = new THREE.PerspectiveCamera(30.0, 1, 0.1, 20.0);
        // Adjust camera position - full body view
        camera.position.set(0.0, 1.2, 5.0);  // Centered, moderate height, show full body

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 0.5, 0.0);  // Target character full body center
        controls.update();

        const scene = new THREE.Scene();

        // Set temporary background color first
        scene.background = new THREE.Color(0x87CEEB);
        
        // Load background image
        AppConfig.debug.log('🎨 Loading background image: BG/chatroom2.png');
        AppConfig.debug.log('🌍 Current URL:', window.location.href);
        
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            './BG/chatroom2.png',
            (texture) => {
                AppConfig.debug.log('🎨 Background texture loaded:', texture);
                AppConfig.debug.log('📐 Texture dimensions:', texture.image.width, 'x', texture.image.height);
                
                // Adjust texture settings for full screen
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.flipY = false; // Prevent image from being flipped
                
                scene.background = texture;
                AppConfig.debug.log('✅ Background image set successfully!');
                
                // Force render once
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            },
            (progress) => {
                const percent = progress.total ? (progress.loaded / progress.total * 100).toFixed(1) : '?';
                AppConfig.debug.log('📊 Background loading progress:', percent + '%');
            },
            (error) => {
                console.error('⚠️ Background image load failed:', error);
                console.error('⚠️ Detail:', error.message);
                console.error('⚠️ Full path:', new URL('BG/chatroom2.png', window.location.href).href);
                // Keep temporary background color
            }
        );

        // Lighting - optimized brightness based on official examples
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.setScalar(1024);
        scene.add(directionalLight);

        // Add supplementary light source to enhance overall brightness
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-1.0, 0.5, -1.0).normalize();
        scene.add(fillLight);

        // Global variables
        let currentVrm = null;
        let currentMixer = null;
        let footShadow = null;

        // Create foot shadow function - reference index.html implementation
        function createFootShadow(vrm) {
            // Remove previous shadow (if exists)
            if (footShadow) {
                scene.remove(footShadow);
                footShadow.geometry.dispose();
                footShadow.material.dispose();
            }

            // Create渐变圆形阴影 - 模仿index.html
            const shadowCanvas = document.createElement('canvas');
            shadowCanvas.width = 128;
            shadowCanvas.height = 128;
            const context = shadowCanvas.getContext('2d');
            
            // Create radial gradient shadow
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)'); // Darker at center
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.2)'); // Medium transparency
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent at edges
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            
            const shadowTexture = new THREE.CanvasTexture(shadowCanvas);
            const shadowGeometry = new THREE.PlaneGeometry(2.2, 2.2);
            const shadowMaterial = new THREE.MeshBasicMaterial({ 
                map: shadowTexture,
                transparent: true,
                alphaTest: 0.001,
                depthWrite: false
            });
            
            footShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            footShadow.rotation.x = -Math.PI / 2;
            footShadow.position.set(0, -0.82, 0); // Directly at foot bottom, consistent with index.html
            scene.add(footShadow);
            
            AppConfig.debug.log('✅ Created foot shadow', {
                position: footShadow.position,
                size: '2.2x2.2'
            });
        }

        // Update阴影位置函数（用于动画时）
        function updateFootShadow() {
            if (!footShadow || !currentVrm) return;
            
            // Keep shadow position fixed at foot bottom
            footShadow.position.x = currentVrm.scene.position.x || 0;
            footShadow.position.y = -0.82; // Fixed height, consistent with index.html
            footShadow.position.z = currentVrm.scene.position.z || 0;
        }
        let currentAction = null;
        let defaultVrmFile = 'Main VRM/Fliza VRM.vrm'; // Default VRM file
        let currentAnimationUrl = null;

        // Expression and AI control variables
        let autoBlinking = true;
        let blinkTimer = 0;
        let blinkFrequency = 3.0;
        let availableExpressions = [];
        let isBlinking = false;
        let blinkDuration = 0.15;
        let aiModeEnabled = true;
        let currentEmotion = 'neutral';
        let isTyping = false;

        // Chat related variables
        let chatHistory = [];

        // Music control variables
        let backgroundMusic = null;
        let isMusicPlaying = false;
        let musicVolume = 0.5; // Default 50% volume

        // Expression related functions
        function getAvailableExpressions(vrm) {
            if (!vrm.expressionManager) return [];

            const expressions = [];
            const presets = ['happy', 'angry', 'sad', 'surprised', 'relaxed', 'blink'];

            presets.forEach(preset => {
                try {
                    const expressionName = vrm.expressionManager.getExpressionTrackName(preset);
                    if (expressionName) {
                        expressions.push(preset);
                    }
                } catch (e) {
                    // Expression does not exist
                }
            });

            (window.AppConfig?.debug?.log || console.log)(`Available expressions: ${expressions.join(', ')}`);
            return expressions;
        }

        function setExpression(expressionName, value) {
            if (!currentVrm || !currentVrm.expressionManager) return;

            try {
                currentVrm.expressionManager.setValue(expressionName, value);
                // console.log(`😊 Setting expression: ${expressionName} = ${value}`);

                // Update状态显示
                if (value > 0.5) {
                    document.getElementById('current-expression').textContent = getEmotionText(expressionName);
                }
            } catch (e) {
                (window.AppConfig?.debug?.warn || console.warn)(`Expression ${expressionName} not available:`, e);
            }
        }

        function resetExpressions() {
            if (!currentVrm || !currentVrm.expressionManager) return;

            availableExpressions.forEach(expr => {
                if (expr !== 'blink') {
                    currentVrm.expressionManager.setValue(expr, 0);
                }
            });

            document.getElementById('current-expression').textContent = 'Neutral';
        }

        // Expression test function
        function testShyExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test bashful expression...');
            (window.AppConfig?.debug?.log || console.log)('Available expressions:', availableExpressions);
            
            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            // Reset所有表情
            resetExpressions();
            
            // Try various shy-related expressions
            const shyExpressions = ['shy', 'embarrassed', 'blush', 'surprised', 'sad'];
            let appliedExpression = null;
            
            shyExpressions.forEach(expr => {
                if (availableExpressions.includes(expr)) {
                    setExpression(expr, 1.0);
                    appliedExpression = expr;
                (window.AppConfig?.debug?.log || console.log)(`Applied expression: ${expr}`);
                }
            });
            
            if (appliedExpression) {
                document.getElementById('current-expression').textContent = `Bashful (${appliedExpression})`;
                // 5秒后恢复
                setTimeout(() => {
                    resetExpressions();
                }, 5000);
            } else {
                alert('This VRM model does not support bashful expression.\nAvailable: ' + availableExpressions.join(', '));
            }
        }

        function testHappyExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test happy expression...');
            
            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            resetExpressions();
            
            if (availableExpressions.includes('happy')) {
                setExpression('happy', 1.0);
                document.getElementById('current-expression').textContent = 'Happy';
                setTimeout(() => resetExpressions(), 3000);
            } else {
                alert('This VRM model does not support happy expression');
            }
        }

        function testSadExpression() {
            (window.AppConfig?.debug?.log || console.log)('Test sad expression...');
            
            if (!currentVrm || !currentVrm.expressionManager) {
                alert('VRM model is not loaded yet!');
                return;
            }

            resetExpressions();
            
            if (availableExpressions.includes('sad')) {
                setExpression('sad', 1.0);
                document.getElementById('current-expression').textContent = 'Sad';
                setTimeout(() => resetExpressions(), 3000);
            } else {
                alert('This VRM model does not support sad expression');
            }
        }

        function resetAllExpressions() {
            (window.AppConfig?.debug?.log || console.log)('Reset all expressions...');
            resetExpressions();
        }

        function performBlink() {
            if (!currentVrm || !availableExpressions.includes('blink') || isBlinking) return;

            isBlinking = true;
            const startTime = performance.now();

            function animateBlink() {
                const elapsed = (performance.now() - startTime) / 1000;
                const progress = elapsed / blinkDuration;

                if (progress < 0.5) {
                    const blinkValue = Math.sin(progress * Math.PI * 2) * 0.5 + 0.5;
                    setExpression('blink', blinkValue);
                } else if (progress < 1.0) {
                    const blinkValue = Math.sin((1 - progress) * Math.PI * 2) * 0.5 + 0.5;
                    setExpression('blink', blinkValue);
                } else {
                    setExpression('blink', 0);
                    isBlinking = false;
                    return;
                }

                requestAnimationFrame(animateBlink);
            }

            animateBlink();
        }

        // Animation loading function
        // Idle animations相关变量
        let idleAnimationUrl = 'mixamo animation/Breathing Idle.fbx';
        let idleAction = null;
        let returnToIdleTimer = null;
        
        async function loadAnimation(animationUrl, emotionName = null) {
            if (!currentVrm) return;

            try {
                // Clear previous return to idle timer
                if (returnToIdleTimer) {
                    clearTimeout(returnToIdleTimer);
                    returnToIdleTimer = null;
                }
                
                currentAnimationUrl = animationUrl;

                // Determine if it is idle animation
                const isIdleAnimation = animationUrl === idleAnimationUrl || animationUrl.includes('Breathing Idle');
                
                // Determine if it is ActorCore or Mixamo animation
                const isActorCore = animationUrl.includes('actorcore animation');
                const clip = isActorCore ?
                    await loadActorCoreAnimation(animationUrl, currentVrm) :
                    await loadMixamoAnimation(animationUrl, currentVrm);

                if (currentMixer) {
                    const newAction = currentMixer.clipAction(clip);
                    newAction.reset().play();
                    newAction.timeScale = 1.0;
                    
                    // If idle animation, set to loop
                    if (isIdleAnimation) {
                        newAction.loop = THREE.LoopRepeat;
                        idleAction = newAction;
                    } else {
                        // Non-idle animations set to play once
                        newAction.loop = THREE.LoopOnce;
                        newAction.clampWhenFinished = true;
                    }

                    if (currentAction && currentAction !== newAction) {
                        currentAction.crossFadeTo(newAction, 1.0, false);
                    }

                    currentAction = newAction;
                    
                    // If not idle animation, set timer to return to idle
                    if (!isIdleAnimation) {
                        // Get animation duration, return to idle after animation ends
                        const animationDuration = clip.duration * 1000; // Convert to milliseconds
                        returnToIdleTimer = setTimeout(() => {
                            // console.log('🔄 Return to idle animation');
                            loadAnimation(idleAnimationUrl);
                        }, animationDuration + 500); // Return to idle 0.5 seconds after animation ends
                    }
                }

                // Update状态显示
                const animationName = animationUrl.split('/').pop().split('.')[0];
                document.getElementById('current-animation').textContent = animationName;

                if (emotionName) {
                    currentEmotion = emotionName;
                    // Set expression simultaneously
                    if (availableExpressions.includes(emotionName)) {
                        setExpression(emotionName, 1.0);
                        setTimeout(() => {
                            setExpression(emotionName, 0);
                        }, 2000);
                    }
                }

                // console.log(`🎬 Animation loaded successfully: ${animationName} (${isActorCore ? 'ActorCore' : 'Mixamo'})`);

            } catch (error) {
                console.error('❌ Animation load failed:', error);
            }
        }

        // VRM character列表
        const vrmCharacters = {
            'Alice': 'Main VRM/Alice.vrm',
            'Fliza VRM': 'Main VRM/Fliza VRM.vrm',
            'QuQu_U': 'Main VRM/QuQu_U.vrm',
            'Ash1.0': 'Main VRM/Ash1.0.vrm',
            'CH_001_imiut': 'Main VRM/CH_001_imiut_v1.01.vrm',
            'CH_007_unkt': 'Main VRM/CH_007_unkt_off_bonnet_v1_00.vrm',
            'Elinyaa': 'Main VRM/Elinyaa.vrm',
            'IMERIS': 'Main VRM/IMERIS.vrm',
            'Lena': 'Main VRM/Lena_ver1.02(VRM).vrm',
            'Lilium': 'Main VRM/Lilium_ver1.01 (VRM).vrm',
            'M_CH_06_Shiratori': 'Main VRM/M_CH_06_Shiratori_v1.00.vrm',
            'Maple': 'Main VRM/Maple_1.0.vrm',
            'NEKONA': 'Main VRM/NEKONA.01.vrm',
            'NecoMaid_Premium': 'Main VRM/NecoMaid_Premium.vrm',
            'RINDO_Full': 'Main VRM/RINDO_Full.vrm',
            'Rainy': 'Main VRM/Rainy_1.00.vrm',
            'NEKO': 'Main VRM/NEKO.vrm',
            'Vivi_model': 'Main VRM/Vivi_model.vrm',
            'Wolf': 'Main VRM/Wolf_ver1.00(VRM).vrm',
            'Wolferia': 'Main VRM/Wolferia.vrm',
            'YM_CH_03_Notia': 'Main VRM/YM_CH_03_Notia_v1.01.vrm',
            'Yawl_Dress': 'Main VRM/Yawl_Dress.vrm',
            'Yuu uwaginasi': 'Main VRM/Yuu uwaginasi.vrm',
            'Yuu': 'Main VRM/Yuu.vrm',
            'kyoko': 'Main VRM/kyoko.vrm',
            'miru': 'Main VRM/miru.vrm',
            'sikirei_Rei': 'Main VRM/sikirei_Rei_VRM.vrm'
        };

        let currentCharacterName = 'Fliza VRM';

        // VRM load函数
        function loadVRM(characterName = null) {
            let vrmPath;
            
            if (characterName) {
                vrmPath = vrmCharacters[characterName];
                if (!vrmPath) {
                    // Try to find character by name mapping for index.html compatibility
                    const nameToVrmKey = {
                        'Neco': 'NEKO',
                        'Nekona': 'NEKONA',
                        'Alice': 'Alice',
                        'Ash': 'Ash1.0',
                        'Fliza': 'Fliza VRM',
                        'QuQu': 'QuQu_U',
                        'Imeris': 'IMERIS',
                        'Rindo': 'RINDO_Full',
                        'Notia': 'YM_CH_03_Notia',
                        'Yawl': 'Yawl_Dress',
                        'Vivi': 'Vivi_model'
                    };
                    
                    const vrmKey = nameToVrmKey[characterName];
                    if (vrmKey && vrmCharacters[vrmKey]) {
                        vrmPath = vrmCharacters[vrmKey];
                        characterName = vrmKey; // Update to VRM key for consistency
                    } else {
                        console.error('❌ Character not found:', characterName);
                        return;
                    }
                }
            } else {
                // Use default or selected character file
                vrmPath = defaultVrmFile;
                // Get selected character info from localStorage
                const selectedCharacterData = localStorage.getItem('selectedCharacter');
                if (selectedCharacterData) {
                    const character = JSON.parse(selectedCharacterData);
                    // Use the file path directly if available, otherwise use name mapping
                    if (character.file) {
                        vrmPath = character.file;
                        characterName = character.name || 'Fliza';
                        
                        // Find the VRM key that matches this file path
                        const vrmKey = Object.keys(vrmCharacters).find(key => vrmCharacters[key] === character.file);
                        if (vrmKey) {
                            characterName = vrmKey;
                        }
                    } else {
                        characterName = character.name || 'Fliza';
                    }
                } else {
                    characterName = 'Fliza';
                }
            }

            // console.log('🎮 VRM loading debug info:');
            // console.log('- characterName:', characterName);
            // console.log('- vrmPath:', vrmPath);
            // console.log('- defaultVrmFile:', defaultVrmFile);

            if (!vrmPath) {
                console.error('❌ VRM file path is empty');
                updateVRMStatus('Failed: empty file path');
                return;
            }

            currentCharacterName = characterName;
            updateVRMStatus('Loading...');

            const loader = new GLTFLoader();
            loader.crossOrigin = 'anonymous';

            // Don't use helperRoot, keep consistent with index.html
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            loader.load(
                vrmPath,
                (gltf) => {
                    // console.log('🎉 VRM file loaded successfully!', gltf);
                    const vrm = gltf.userData.vrm;
                    // console.log('📦 VRM object:', vrm);

                    // Use VRM v2 compatible optimization method
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    // VRMUtils.combineSkeletons 在 v2 中已移除
                    // VRMUtils.combineMorphs 在 v2 中已移除

                    if (currentVrm) {
                        scene.remove(currentVrm.scene);
                        VRMUtils.deepDispose(currentVrm.scene);
                    }
                    
                    // Clean up previous shadows
                    if (footShadow) {
                        scene.remove(footShadow);
                        footShadow.geometry.dispose();
                        footShadow.material.dispose();
                        footShadow = null;
                    }

                    currentVrm = vrm;
                    scene.add(vrm.scene);

                    // VRM模型大小和位置Setting - 与index.html一致
                    vrm.scene.scale.set(1.45, 1.45, 1.45);  // Same scaling ratio as character selection page

                    // Move VRM model position down, closer to bottom boundary
                    vrm.scene.position.y = -0.8;  // Same position as character selection page
                    
                    // Create脚底阴影
                    createFootShadow(vrm);

                    currentMixer = new THREE.AnimationMixer(currentVrm.scene);

                    vrm.scene.traverse((obj) => {
                        obj.frustumCulled = false;
                    });

                    // VRMUtils.rotateVRM0 may be unnecessary or changed in v2
                    try {
                        VRMUtils.rotateVRM0(vrm);
                    } catch (error) {
                        (window.AppConfig?.debug?.warn || console.warn)('VRMUtils.rotateVRM0 not available; skip (VRM v2 compat)');
                    }

                    availableExpressions = getAvailableExpressions(vrm);
                    
                    // Update全局变量
                    window.currentVrm = currentVrm;
                    window.availableExpressions = availableExpressions;

                    updateVRMStatus('✅ Loaded');
                    
                    // Updatecharacter名称显示
                    const characterNameElement = document.getElementById('character-name');
                    if (characterNameElement) {
                        characterNameElement.textContent = characterName;
                    }

                    // Play idle animation by default
                    loadAnimation(idleAnimationUrl);

                    // console.log('🎭 VRM loaded:', vrm);
                    
                    // InitializeAIchat system
                    onVRMLoadComplete(currentCharacterName, vrmPath);
                },
                (progress) => {
                    const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
                    // console.log(`📊 VRM loading: ${percent}%`, progress);
                    updateVRMStatus(`Loading... ${percent}%`);
                },
                (error) => {
                    console.error('❌ VRM load failed:', error);
                    console.error('❌ Detail:', error.message, error.stack);
                    console.error('❌ VRM path attempted:', vrmPath);
                    console.error('❌ Current location:', window.location.href);
                    updateVRMStatus(`❌ Failed: ${error.message || error}`);
                }
            );
        }

        // Status update function
        function updateVRMStatus(status) {
            document.getElementById('vrm-loaded').textContent = status;
        }

        function getEmotionText(emotion) {
            const emotionMap = {
                happy: '开心',
                sad: '伤心',
                angry: '生气',
                surprised: '惊讶',
                thinking: '思考',
                neutral: '中性',
                bashful: '害羞'
            };
            return emotionMap[emotion] || '中性';
        }

        // AI 聊天函数
        function analyzeMessage(message) {
            // Simple keyword emotion analysis
            for (const [keyword, emotion] of Object.entries(keywordEmotionMap)) {
                if (message.includes(keyword)) {
                    return emotion;
                }
            }
            return 'neutral';
        }

        function generateAIResponse(userMessage) {
            // Simple AI reply system (can connect to real AI API later)
            const responses = {
                greeting: [
                    "Hello! Nice to meet you~ 💕",
                    "Hi! How's your day going?",
                    "Welcome back! I've been waiting for you~"
                ],
                happy: [
                    "Wow! You look so happy! I'm happy too~ 😊",
                    "Great! Your joy is contagious!",
                    "Seeing you happy makes me want to dance!"
                ],
                sad: [
                    "Don't be sad, I'll always be here with you... 😢",
                    "Although it's hard now, everything will get better!",
                    "Come, let me give you a hug~"
                ],
                angry: [
                    "Don't be angry, take a deep breath~ 😤",
                    "I know you're angry, but anger can hurt your body",
                    "Tell me what happened, I'll help you figure it out!"
                ],
                surprised: [
                    "Really?! That's so surprising! 😲",
                    "Wow! Didn't expect that!",
                    "That's really unexpected!"
                ],
                thinking: [
                    "Hmm...let me think about that... 🤔",
                    "That's definitely worth thinking about",
                    "You're right, I'm thinking about that too"
                ],
                love: [
                    "I like you too~ 💕",
                    "Really? I'm so happy!",
                    "You're making me blush~"
                ],
                default: [
                    "Mm-hmm, I understand~",
                    "I see, that's interesting!",
                    "You make a good point~",
                    "I think so too!",
                    "What do you think?"
                ]
            };

            // Detect special keywords
            if (userMessage.includes('love') || userMessage.includes('like you') || userMessage.includes('I love you')) {
                return responses.love[Math.floor(Math.random() * responses.love.length)];
            }

            const emotion = analyzeMessage(userMessage);
            const responseArray = responses[emotion] || responses.default;
            return responseArray[Math.floor(Math.random() * responseArray.length)];
        }

        // Character class name mapping
        function getCharacterClassName(characterName) {
            const nameMapping = {
                '芙莉莎': 'character-fliza',
                'Fliza': 'character-fliza', 
                'Alice': 'character-alice',
                'Ash': 'character-ash',
                'Bobo': 'character-bobo',
                'Elinyaa': 'character-elinyaa',
                'Imeris': 'character-imeris',
                'Kyoko': 'character-kyoko',
                'Lena': 'character-lena',
                'Lilium': 'character-lilium',
                'Maple': 'character-maple',
                'Miru': 'character-miru',
                'Miumiu': 'character-miumiu',
                'Neco': 'character-neco',
                'Nekona': 'character-nekona',
                'Notia': 'character-notia',
                'Ququ': 'character-ququ',
                'Rainy': 'character-rainy',
                'Rindo': 'character-rindo',
                'Sikirei': 'character-sikirei',
                'Vivi': 'character-vivi',
                'Wolf': 'character-wolf',
                'Wolferia': 'character-wolferia',
                'Yawl': 'character-yawl',
                'Yuu': 'character-yuu',
                'Zwei': 'character-zwei'
            };
            return nameMapping[characterName] || 'character-alice'; // Default to Alice
        }

        // Chat UI functions
        
        // Update流式消息内容
        function updateStreamingMessageUI(messageId, content) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const messageContent = messageElement.querySelector('.message-text');
                if (messageContent) {
                    messageContent.textContent = content;
                    
                    // Add typing effect cursor
                    if (!content.endsWith('|')) {
                        messageContent.textContent += '|';
                        setTimeout(() => {
                            if (messageContent.textContent.endsWith('|')) {
                                messageContent.textContent = content;
                            }
                        }, 500);
                    }
                    
                    // Keep scrolled to bottom
                    const messagesContainer = document.getElementById('chat-window-messages');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Only update dialogue bubble text, don't restart animation
                    updateSpeechBubbleContent(content);
                }
            }
        }
        
        // Speech bubble state management
        let speechBubbleState = {
            isActive: false,
            currentAnimation: null,
            timeoutId: null
        };
        
        // Show AI dialogue bubble
        function showSpeechBubble(text) {
            // console.log('🗨️ showSpeechBubble called with text:', text);
            const bubble = document.getElementById('ai-speech-bubble');
            
            if (!bubble) {
                console.error('❌ Speech bubble element not found!');
                return;
            }
            
            // Clear previous state
            if (speechBubbleState.timeoutId) {
                clearTimeout(speechBubbleState.timeoutId);
            }
            
            bubble.style.display = 'block';
            bubble.style.animation = 'bubbleFadeIn 0.5s forwards';
            speechBubbleState.isActive = true;
            
            // Typewriter effect - display character by character
            let currentIndex = 0;
            bubble.textContent = '';
            
            function typeText() {
                if (currentIndex < text.length && speechBubbleState.isActive) {
                    bubble.textContent += text[currentIndex];
                    currentIndex++;
                    speechBubbleState.timeoutId = setTimeout(typeText, 100);
                } else if (speechBubbleState.isActive) {
                    // After text display completes, stay longer
                    const displayTime = Math.max(5000, text.length * 200);
                    
                    // console.log(`💬 Subtitle bubble display time: ${displayTime}ms (text length: ${text.length}characters)`);
                    
                    speechBubbleState.timeoutId = setTimeout(() => {
                        if (speechBubbleState.isActive) {
                            bubble.style.animation = 'bubbleFadeOut 1s forwards';
                            speechBubbleState.timeoutId = setTimeout(() => {
                                bubble.style.display = 'none';
                                speechBubbleState.isActive = false;
                            }, 1000);
                        }
                    }, displayTime);
                }
            }
            
            // Start打characters效果
            speechBubbleState.timeoutId = setTimeout(typeText, 200); // Start typing 200ms after bubble appears
        }
        
        // Speech bubble streaming update state
        let bubbleStreamingState = {
            isStreaming: false,
            pendingText: '',
            streamStartTime: null
        };
        
        // Update对话气泡内容（流式更新时使用，不重启动画）
        function updateSpeechBubbleContent(text) {
            // Mark as streaming update state
            if (!bubbleStreamingState.isStreaming) {
                bubbleStreamingState.isStreaming = true;
                bubbleStreamingState.streamStartTime = Date.now();
                console.log('🎬 Starting streaming speech bubble update');
            }
            
            // Save latest complete text
            bubbleStreamingState.pendingText = text;
            
            // Setup延迟显示，避免频繁更新
            if (bubbleStreamingState.timeoutId) {
                clearTimeout(bubbleStreamingState.timeoutId);
            }
            
            bubbleStreamingState.timeoutId = setTimeout(() => {
                // If still in streaming update, check if should display
                const timeSinceStart = Date.now() - bubbleStreamingState.streamStartTime;
                
                // If streaming update has stopped for more than 500ms, consider completed
                if (timeSinceStart > 500) {
                    console.log('✨ Streaming update completed, showing final speech bubble');
                    bubbleStreamingState.isStreaming = false;
                    showSpeechBubble(bubbleStreamingState.pendingText);
                }
            }, 500); // Delay 500ms waiting for streaming update to complete
        }


        async function sendMessage() {
            // Validateuser是否已认证
            if (!walletAuth.isAuthenticated) {
                console.error('❌ user not authenticated, cannot send message');
                walletAuth.showUnauthorizedOverlay();
                return;
            }

            const input = document.getElementById('chat-input-field');
            const message = input.value.trim();

            if (!message) return;

            // Get current user and character info
            const userId = walletAuth.getCurrentUserId();
            const character = walletAuth.getCurrentCharacter();

            // console.log(`💬 Sending message: ${message} (user: ${walletAuth.formatAddress(userId)}, character: ${character.name})`);

            // Clear输入框
            input.value = '';

            // Analyze emotion and trigger animation
            if (aiModeEnabled) {
                const emotion = analyzeMessage(message);
                if (emotion !== 'neutral') {
                    triggerEmotion(emotion);
                }
            }

            try {
                // Use ElizaOS integrated ChatSystem V2
                if (window.chatSystemV2) {
                    // console.log('🤖 Using ElizaOS ChatSystem V2 to send message');
                    
                    // Ensure ChatSystem V2 has correct user and character settings
                    if (!window.chatSystemV2.currentUser) {
                        // Simulate user object, let ChatSystem V2 think user is logged in
                        window.chatSystemV2.currentUser = {
                            id: userId,
                            nickname: `user${userId.slice(-4)}`,
                            walletAddress: userId
                        };
                        window.chatSystemV2.waitingForWallet = false;
                        // console.log('👤 Setting ChatSystem V2 user:', window.chatSystemV2.currentUser.nickname);
                    }
                    
                    // Ensure ChatSystem V2 has correct character settings
                    if (!window.chatSystemV2.currentCharacter && selectedCharacter) {
                        // console.log('🎭 Setting ChatSystem V2 character:', selectedCharacter.name);
                        window.chatSystemV2.setCharacter(selectedCharacter);
                    }
                    
                    // Double check: if still no character, use current character data
                    if (!window.chatSystemV2.currentCharacter) {
                        const characterData = {
                            name: character.name,
                            id: character.id || character.name.toLowerCase(),
                            personality: character.personality,
                            ...character
                        };
                        // console.log('🎭 Setting ChatSystem V2 with current character data:', characterData.name);
                        window.chatSystemV2.setCharacter(characterData);
                    }
                    
                    // Use ChatSystem V2 to send message (includes OpenAI integration)
                    await window.chatSystemV2.sendMessage(message);
                    
                    // ChatSystem V2 会处理消息显示和历史记录
                    // console.log('✅ ElizaOS message sending completed');
                    
                } else {
                    // Fall back to old system
                    console.log('⚠️ Falling back to old preset reply system');
                    let response;
                    
                    // If memory system is initialized, use enhanced AI reply
                    if (window.memorySystem && window.memorySystem.initialized) {
                        // 1. 检索记忆上下文
                        const memoryContext = await window.memorySystem.retrieveMemoryContext(userId, character.id, message);
                        
                        // 2. 构建增强的AI上下文
                        const npcPersona = getNPCPersona(character.id);
                        const contextPrompt = window.memorySystem.buildContextForAI(memoryContext, npcPersona);
                        
                        // 3. generated带记忆的AI回复
                        response = await generateAIResponseWithMemory(message, contextPrompt);
                    } else {
                        // Finally fall back to simple AI reply
                        response = generateAIResponse(message);
                    }

                    // AI reply handled by ElizaOS system

                    // Analyze AI reply and possibly trigger additional animation
                    const aiEmotion = analyzeMessage(response);
                    if (aiEmotion !== 'neutral' && aiModeEnabled) {
                        setTimeout(() => triggerEmotion(aiEmotion), 500);
                    }

                    // Save conversation to memory system
                    if (window.memorySystem && window.memorySystem.initialized) {
                        await window.memorySystem.processConversationMemories(userId, character.id, message, response);
                    } else {
                        // Fall back to save to localStorage
                        saveChatHistory(userId, character.id, message, response);
                    }
                }

            } catch (error) {
                console.error('❌ Failed to send message:', error);
                
                // Final fallback handling
                // Fallback disabled - using ElizaOS system only
            }
        }

        // Save chat records (simple version)
        function saveChatHistory(userId, characterId, userMessage, aiResponse) {
            try {
                const historyKey = `chat_history_${userId}_${characterId}`;
                let history = JSON.parse(localStorage.getItem(historyKey) || '[]');
                
                // Add new conversation
                history.push({
                    timestamp: new Date().toISOString(),
                    user: userMessage,
                    ai: aiResponse
                });
                
                // Only keep recent 50 conversations
                if (history.length > 50) {
                    history = history.slice(-50);
                }
                
                localStorage.setItem(historyKey, JSON.stringify(history));
                console.log('💾 Chat history saved');
                
            } catch (error) {
                console.error('Failed to save chat history:', error);
            }
        }

        function sendChatMessage() {
            sendMessage();
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Emotion trigger function
        function triggerEmotion(emotion) {
            if (!currentVrm) return;

            // console.log(`🎭 Triggering emotion: ${emotion}`);

            // Reset按钮状态
            document.querySelectorAll('.emotion-btn').forEach(btn => btn.classList.remove('active'));

            // Activate corresponding button
            const emotionBtns = document.querySelectorAll('.emotion-btn');
            emotionBtns.forEach(btn => {
                if (btn.textContent.includes(getEmotionText(emotion))) {
                    btn.classList.add('active');
                }
            });

            if (emotion === 'neutral') {
                resetExpressions();
                loadAnimation(idleAnimationUrl);
                return;
            }

            // Load对应动画
            if (emotionAnimationMap[emotion]) {
                loadAnimation(emotionAnimationMap[emotion], emotion);
            }

            // Setup表情
            if (availableExpressions.includes(emotion)) {
                resetExpressions();
                setExpression(emotion, 1.0);

                // 3秒后恢复中性表情
                setTimeout(() => {
                    setExpression(emotion, 0);
                    document.getElementById('current-expression').textContent = '中性';
                }, 3000);
            }
        }

        function toggleAutoMode() {
            aiModeEnabled = !aiModeEnabled;
            document.getElementById('ai-mode-status').textContent = aiModeEnabled ? i18n.t('status.enabled') : i18n.t('status.disabled');
            document.getElementById('ai-status').innerHTML = aiModeEnabled ?
                '<span class="online-indicator"></span>' + i18n.t('status.ai.smart') :
                '<span class="online-indicator"></span>' + i18n.t('status.manual');
        }

        function toggleDebugMode() {
            helperRoot.visible = !helperRoot.visible;
            console.log(`🦴 Bone debug mode: ${helperRoot.visible ? 'enabled' : 'disabled'}`);
        }

        // Music control functions
        function initBackgroundMusic() {
            backgroundMusic = document.getElementById('background-music');

            if (backgroundMusic) {
                backgroundMusic.volume = musicVolume;
                // console.log('🎵 Background music element found, volume set to:', musicVolume);

                // Initialize button state to match isMusicPlaying
                updateMusicButton();

                // Music loaded successfully event
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('🎵 Background music loading complete');
                });

                // Music loading error event
                backgroundMusic.addEventListener('error', (e) => {
                    console.warn('⚠️ Background music loading failed:', e);
                    console.warn('⚠️ Audio source:', backgroundMusic.src || backgroundMusic.currentSrc);
                    document.getElementById('music-controls').style.display = 'none';
                });

                // Add loadstart event for debugging
                backgroundMusic.addEventListener('loadstart', () => {
                    // console.log('🎵 Started loading background music from:', backgroundMusic.src || backgroundMusic.currentSrc);
                });

                // Try auto play
                playBackgroundMusic();
            } else {
                console.error('❌ Background music element not found');
            }
        }

        function playBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                    updateMusicButton();
                    // console.log('🎵 Background music started playing');
                    // Remove fixed background music message
                }).catch(error => {
                    console.log('🎵 Auto-play blocked by browser, waiting for user interaction');
                    isMusicPlaying = false;
                    updateMusicButton();
                    
                    // Add user interaction listeners to start music
                    function startMusicOnInteraction() {
                        if (backgroundMusic && !isMusicPlaying) {
                            backgroundMusic.play().then(() => {
                                isMusicPlaying = true;
                                updateMusicButton();
                                // console.log('🎵 Background music started after user interaction');
                            }).catch(e => {
                                console.log('⚠️ Could not start background music:', e);
                            });
                        }
                        // Remove event listeners after first successful play
                        document.removeEventListener('click', startMusicOnInteraction);
                        document.removeEventListener('keydown', startMusicOnInteraction);
                        document.removeEventListener('touchstart', startMusicOnInteraction);
                    }

                    // Add event listeners for user interaction
                    document.addEventListener('click', startMusicOnInteraction);
                    document.addEventListener('keydown', startMusicOnInteraction);
                    document.addEventListener('touchstart', startMusicOnInteraction);
                });
            }
        }

        function toggleMusic() {
            if (!backgroundMusic) return;

            if (isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            } else {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                }).catch(error => {
                    console.error('🎵 Music playback failed:', error);
                });
            }
            updateMusicButton();
        }

        function adjustVolume(value) {
            musicVolume = value / 100;
            if (backgroundMusic) {
                backgroundMusic.volume = musicVolume;
            }
            document.getElementById('volume-label').textContent = value + '%';

            // Update volume icon based on volume
            const volumeIcon = document.querySelector('.volume-control span');
            if (value == 0) {
                volumeIcon.textContent = '🔇';
            } else if (value < 30) {
                volumeIcon.textContent = '🔈';
            } else if (value < 70) {
                volumeIcon.textContent = '🔉';
            } else {
                volumeIcon.textContent = '🔊';
            }
        }

        function updateMusicButton() {
            const button = document.getElementById('music-toggle');
            if (isMusicPlaying) {
                button.textContent = '⏸';
                button.classList.remove('paused');
            } else {
                button.textContent = '▶';
                button.classList.add('paused');
            }
        }

        // Language switch function - globally accessible
        window.switchLanguage = function(lang) {
            if (window.i18n) {
                window.i18n.switchLanguage(lang);
            }
        };

        // Initialize language switcher
        function initLanguageToggle() {
            if (window.i18n) {
                const currentLang = window.i18n.getCurrentLanguage();
                const enBtn = document.getElementById('lang-en');
                const zhBtn = document.getElementById('lang-zh');
                
                if (enBtn && zhBtn) {
                    enBtn.classList.toggle('active', currentLang === 'en');
                    zhBtn.classList.toggle('active', currentLang === 'zh');
                }
            }
        }

        function initAnimationSelector() {
            const selector = document.getElementById('animation-selector');
            // 检查元素是否存在，如果不存在则跳过
            if (!selector) {
                // console.log('🎭 Animation selector element not found, skipping initialization');
                return;
            }
            // Clear现有选项
            selector.innerHTML = '<option value="">' + i18n.t('panel.select.animation') + '</option>';

            // Add all animation options
            Object.keys(animationMap).sort().forEach(animationName => {
                const option = document.createElement('option');
                option.value = animationName;
                option.textContent = animationName;
                selector.appendChild(option);
            });
        }

        function initCharacterSelector() {
            const selector = document.getElementById('character-selector');
            // 检查元素是否存在，如果不存在则跳过
            if (!selector) {
                // console.log('🎭 Character selector element not found, skipping initialization');
                return;
            }
            // Clear现有选项
            selector.innerHTML = '<option value="">' + i18n.t('panel.select.character') + '</option>';

            // Add all character options
            Object.keys(vrmCharacters).sort().forEach(characterName => {
                const option = document.createElement('option');
                option.value = characterName;
                option.textContent = characterName;
                selector.appendChild(option);
            });

            // Setup默认选中的character
            selector.value = currentCharacterName;
        }

        function changeCharacter() {
            const selector = document.getElementById('character-selector');
            const selectedCharacter = selector.value;

            if (!selectedCharacter) {
                return;
            }

            if (selectedCharacter === currentCharacterName) {
                return;
            }

            console.log(`👤 Switching character: ${currentCharacterName} -> ${selectedCharacter}`);

            // Update聊天头部的character名称
            const characterNames = {
                'Fliza VRM': '芙莉莎',
                'QuQu_U': 'QuQu',
                'Ash1.0': 'Ash',
                'CH_001_imiut': 'Imiut',
                'CH_007_unkt': 'Unkt',
                'Elinyaa': 'Elinyaa',
                'IMERIS': 'Imeris',
                'Lena': 'Lena',
                'Lilium': 'Lilium',
                'M_CH_06_Shiratori': 'Shiratori',
                'Maple': 'Maple',
                'NEKONA': 'Nekona',
                'NecoMaid_Premium': 'NecoMaid',
                'RINDO_Full': 'Rindo',
                'Rainy': 'Rainy',
                'NEKO': 'Neco',
                'Vivi_model': 'Vivi',
                'Wolf': 'Wolf',
                'Wolferia': 'Wolferia',
                'YM_CH_03_Notia': 'Notia',
                'Yawl_Dress': 'Yawl',
                'Yuu uwaginasi': 'Yuu',
                'Yuu': 'Yuu',
                'kyoko': 'Kyoko',
                'miru': 'Miru',
                'sikirei_Rei': 'Rei'
            };

            const displayName = characterNames[selectedCharacter] || selectedCharacter;
            document.querySelector('.chat-user-details h1').textContent = displayName;

            // Load新character
            loadVRM(selectedCharacter);

            // Setupcharacter头像
            setCharacterAvatar(selectedCharacter);

            // Add character switch message
            // Welcome message handled by ElizaOS system
        }

        // Setupcharacter头像的函数
        let lastSetAvatar = null; // Prevent repeatedly setting same avatar
        function setCharacterAvatar(characterKey) {
            // Prevent repeatedly setting same avatar
            if (lastSetAvatar === characterKey) {
                return;
            }
            lastSetAvatar = characterKey;
            
            // Character name to CSS class mapping (supports two formats: id and VRM filename)
            const characterToClass = {
                // ID-based mapping (from index.html)
                'alice': 'character-alice',
                'ash': 'character-ash',
                'elinyaa': 'character-elinyaa',
                'fliza': 'character-fliza',
                'imeris': 'character-imeris',
                'kyoko': 'character-kyoko',
                'lena': 'character-lena',
                'lilium': 'character-lilium',
                'maple': 'character-maple',
                'miru': 'character-miru',
                'miumiu': 'character-miumiu',
                'neco': 'character-neco',
                'nekona': 'character-nekona',
                'notia': 'character-notia',
                'ququ': 'character-ququ',
                'rainy': 'character-rainy',
                'rindo': 'character-rindo',
                'sikirei': 'character-sikirei',
                'vivi': 'character-vivi',
                'wolf': 'character-wolf',
                'wolferia': 'character-wolferia',
                'yawl': 'character-yawl',
                'yuu': 'character-yuu',
                'zwei': 'character-zwei',
                'bobo': 'character-bobo',
                // VRM filename-based mapping (for character switching)
                'Fliza VRM': 'character-fliza',
                'QuQu_U': 'character-ququ', 
                'Ash1.0': 'character-ash',
                'CH_001_imiut': 'character-imeris',
                'Elinyaa': 'character-elinyaa',
                'IMERIS': 'character-imeris',
                'Lena': 'character-lena',
                'Lilium': 'character-lilium',
                'Maple': 'character-maple',
                'NEKONA': 'character-nekona',
                'NecoMaid_Premium': 'character-neco',
                'RINDO_Full': 'character-rindo',
                'Rainy': 'character-rainy',
                'NEKO': 'character-neco',
                'Vivi_model': 'character-vivi',
                'Wolf': 'character-wolf',
                'Wolferia': 'character-wolferia',
                'YM_CH_03_Notia': 'character-notia',
                'Yawl_Dress': 'character-yawl',
                'Yuu uwaginasi': 'character-yuu',
                'Yuu': 'character-yuu',
                'kyoko': 'character-kyoko',
                'miru': 'character-miru',
                'sikirei_Rei': 'character-sikirei'
            };

            // Remove all previous character classes
            const body = document.body;
            const existingClasses = body.className.split(' ').filter(cls => !cls.startsWith('character-'));
            const newClass = characterToClass[characterKey] || characterToClass[characterKey.toLowerCase()] || 'character-alice';
            
            body.className = existingClasses.concat([newClass]).join(' ');
            
            AppConfig.debug.log(`🖼️ Setting character avatar: ${characterKey} -> ${newClass}`);
        }

        function playSelectedAnimation() {
            const selector = document.getElementById('animation-selector');
            if (!selector) {
                console.log('🎭 Animation selector element not found');
                return;
            }
            const selectedAnimation = selector.value;

            if (!selectedAnimation) {
                alert('请先选择一个动画！');
                return;
            }

            if (!currentVrm) {
                alert('VRM模型还未Loading complete！');
                return;
            }

            const animationPath = animationMap[selectedAnimation];
            if (animationPath) {
                // console.log(`🎬 Play animation: ${selectedAnimation}`);
                loadAnimation(animationPath);
                document.getElementById('current-animation').textContent = selectedAnimation;
            } else {
                console.error(`❌ Animation not found: ${selectedAnimation}`);
            }
        }

        // Window size adjustment
        function resizeRenderer() {
            const container = document.querySelector('.vrm-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        window.addEventListener('resize', resizeRenderer);

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // Auto blink logic
            if (autoBlinking && currentVrm && availableExpressions.includes('blink')) {
                blinkTimer += deltaTime;
                if (blinkTimer >= blinkFrequency) {
                    performBlink();
                    blinkTimer = 0;
                    blinkTimer = -Math.random() * 0.5;
                }
            }

            if (currentMixer) {
                currentMixer.update(deltaTime);
            }

            if (currentVrm) {
                currentVrm.update(deltaTime);
                // Update脚底阴影位置
                updateFootShadow();
            }

            renderer.render(scene, camera);
        }

        // Wallet verification system
        class WalletAuthenticator {
            constructor() {
                this.walletAddress = null;
                this.isAuthenticated = false;
                this.selectedCharacter = null;
            }
            
            // Checkwallet验证状态
            checkAuthentication() {
                AppConfig.debug.log('🔍 Starting wallet verification process...');
                
                // 1. 检查localStorage中的wallet地址
                this.walletAddress = localStorage.getItem('wallet_address');
                AppConfig.debug.log('💰 localStorage wallet address:', this.walletAddress);
                
                // 2. 检查选择的character信息
                const selectedCharacterData = localStorage.getItem('selectedCharacter');
                AppConfig.debug.log('👤 localStorage character data:', selectedCharacterData);
                
                // Detect old format data and clean up
                if (selectedCharacterData) {
                    try {
                        const characterData = JSON.parse(selectedCharacterData);
                        if (characterData.personality || characterData.dailyInterests) {
                            console.log('🧹 Detected old format character data, cleaning...');
                            localStorage.removeItem('selectedCharacter');
                            console.log('✅ Cleaned old format data, need to reselect character');
                        }
                    } catch (e) {
                        console.log('⚠️ Character data format abnormal, cleaning...');
                        localStorage.removeItem('selectedCharacter');
                    }
                }
                
                if (!this.walletAddress) {
                    console.log('❌ Wallet address not found, need to re-login');
                    console.log('📊 localStorage content check:');
                    console.log('  - wallet_address:', localStorage.getItem('wallet_address'));
                    console.log('  - selectedCharacter:', localStorage.getItem('selectedCharacter'));
                    this.showUnauthorizedOverlay();
                    return false;
                }
                
                if (!selectedCharacterData) {
                    console.log('❌ Character selection info not found, redirecting to character selection page');
                    this.redirectToCharacterSelect();
                    return false;
                }
                
                try {
                    this.selectedCharacter = JSON.parse(selectedCharacterData);
                    AppConfig.debug.log('📦 Parsed character data:', this.selectedCharacter);
                    
                    // ValidateWallet in character data地址是否匹配
                    if (this.selectedCharacter.walletAddress !== this.walletAddress) {
                        console.log('⚠️ Wallet address mismatch:');
                        console.log('  - Wallet in character data:', this.selectedCharacter.walletAddress);
                        console.log('  - Wallet in localStorage:', this.walletAddress);
                        console.log('  - Redirecting to character selection page');
                        this.redirectToCharacterSelect();
                        return false;
                    }
                    
                    this.isAuthenticated = true;
                    this.updateWalletUI();
                    AppConfig.debug.log('✅ Wallet verification successful:', this.walletAddress);
                    AppConfig.debug.log('✅ Verified character:', this.selectedCharacter.name);
                    return true;
                    
                } catch (error) {
                    console.error('❌ Character data parsing failed:', error);
                    console.error('❌ Raw data:', selectedCharacterData);
                    this.redirectToCharacterSelect();
                    return false;
                }
            }
            
            // Show unauthorized overlay
            showUnauthorizedOverlay() {
                const overlay = document.getElementById('unauthorized-overlay');
                const chatWindow = document.getElementById('floating-chat');
                const controls = document.querySelector('.control-panel');
                const musicControls = document.querySelector('.music-controls');
                
                // Hide chat related UI
                if (chatWindow) chatWindow.style.display = 'none';
                if (controls) controls.style.display = 'none';
                if (musicControls) musicControls.style.display = 'none';
                
                // Show unauthorized prompt
                overlay.style.display = 'flex';
            }
            
            // UpdatewalletUI显示
            updateWalletUI() {
                const walletStatusInfo = document.getElementById('wallet-status-info');
                const walletAddressElement = document.getElementById('wallet-address');
                
                if (this.walletAddress) {
                    walletStatusInfo.style.display = 'flex';
                    walletAddressElement.textContent = this.formatAddress(this.walletAddress);
                    
                    // Updatecharacter名称显示
                    if (this.selectedCharacter) {
                        const characterNameElement = document.getElementById('character-name');
                        if (characterNameElement) {
                            characterNameElement.textContent = this.selectedCharacter.name;
                        }
                        
                        // Welcome message handled by ElizaOS system
                    }
                }
            }
            
            // Format address display
            formatAddress(address) {
                return `${address.slice(0, 4)}...${address.slice(-4)}`;
            }
            
            // Disconnectwallet连接
            disconnect() {
                (window.AppConfig?.debug?.log || console.log)('walletAuth.disconnect called');
                (window.AppConfig?.debug?.log || console.log)('localStorage snapshot taken');
                if (confirm('Disconnect wallet? This will clear local data.')) {
                    (window.AppConfig?.debug?.log || console.log)('User confirmed disconnect');
                    // Clear related data
                    (window.AppConfig?.debug?.log || console.log)('Clearing wallet_address');
                    localStorage.removeItem('wallet_address');
                    (window.AppConfig?.debug?.log || console.log)('Clearing wallet_type');
                    localStorage.removeItem('wallet_type');
                    (window.AppConfig?.debug?.log || console.log)('Clearing selectedCharacter');
                    localStorage.removeItem('selectedCharacter');
                    
                    // Clear character memory data (optional)
                    const keys = Object.keys(localStorage);
                    (window.AppConfig?.debug?.log || console.log)('Check keys to clear memory data:', keys);
                    keys.forEach(key => {
                        if (key.startsWith('memory_') || key.startsWith('user_profile_')) {
                            localStorage.removeItem(key);
                        }
                    });
                    
                    // Redirect to character selection page
                    this.redirectToCharacterSelect();
                }
            }
            
            // Redirect to character selection page
            redirectToCharacterSelect() {
                window.location.href = 'index.html';
            }
            
            // Get current user ID (wallet address)
            getCurrentUserId() {
                return this.walletAddress;
            }
            
            // Get current character info
            getCurrentCharacter() {
                return this.selectedCharacter;
            }
        }
        
        // Global wallet verification instance
        const walletAuth = new WalletAuthenticator();
        window.walletAuth = walletAuth;
        
        // Wallet related global functions
        window.disconnectWallet = function() {
            console.log('🔌 disconnectWallet called');
            if (walletAuth) {
                walletAuth.disconnect();
            } else {
                console.error('❌ walletAuth is undefined');
            }
        };
        
        window.redirectToCharacterSelect = function() {
            walletAuth.redirectToCharacterSelect();
        };
        
        // Test function - force logout
        window.forceDisconnect = function() {
            console.log('🧪 Force logout test');
            localStorage.clear();
            location.href = 'index.html';
        };

        // Jump to character selection page
        function goToCharacterSelect() {
            window.location.href = 'index.html';
        }

        // Drag functionality
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        function initDragAndDrop() {
            const chatHeader = document.querySelector('.chat-window-header');
            const chatWindow = document.getElementById('floating-chat');
            
            // Setup聊天框的初始绝对位置，避免依赖CSS transform
            const windowHeight = window.innerHeight;
            const chatHeight = chatWindow.offsetHeight;
            const initialTop = Math.max(0, (windowHeight - chatHeight) / 2);
            
            chatWindow.style.top = initialTop + 'px';
            chatWindow.style.right = '20px';
            chatWindow.style.left = 'auto';
            chatWindow.style.transform = 'none';
            
            chatHeader.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dragEnd);
            
            // Touch event support
            chatHeader.addEventListener('touchstart', dragStart);
            document.addEventListener('touchmove', dragMove);
            document.addEventListener('touchend', dragEnd);
        }

        function dragStart(e) {
            const chatWindow = document.getElementById('floating-chat');
            
            e.preventDefault();
            
            // Get actual position of current window
            const rect = chatWindow.getBoundingClientRect();
            
            if (e.type === 'touchstart') {
                initialX = e.touches[0].clientX - rect.left;
                initialY = e.touches[0].clientY - rect.top;
            } else {
                initialX = e.clientX - rect.left;
                initialY = e.clientY - rect.top;
            }

            isDragging = true;
            // Don't immediately add dragging class, only add when actually moving
        }

        function dragMove(e) {
            if (!isDragging) return;
            
            e.preventDefault();
            
            const chatWindow = document.getElementById('floating-chat');
            
            // Only add dragging style when actually moving
            if (!chatWindow.classList.contains('dragging')) {
                chatWindow.classList.add('dragging');
            }
            
            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX - initialX;
                currentY = e.touches[0].clientY - initialY;
            } else {
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
            }
            
            // Limit drag range within screen
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const chatWidth = chatWindow.offsetWidth;
            const chatHeight = chatWindow.offsetHeight;
            
            // Calculate boundary limits
            const minX = 0;
            const maxX = windowWidth - chatWidth;
            const minY = 0;
            const maxY = windowHeight - chatHeight;
            
            currentX = Math.max(minX, Math.min(maxX, currentX));
            currentY = Math.max(minY, Math.min(maxY, currentY));
            
            chatWindow.style.left = currentX + 'px';
            chatWindow.style.top = currentY + 'px';
            chatWindow.style.right = 'auto';
            chatWindow.style.transform = 'none';
        }

        function dragEnd(e) {
            if (!isDragging) return;
            
            const chatWindow = document.getElementById('floating-chat');
            isDragging = false;
            chatWindow.classList.remove('dragging');
        }

        // Global function export
        window.triggerEmotion = triggerEmotion;
        window.toggleAutoMode = toggleAutoMode;
        window.toggleDebugMode = toggleDebugMode;
        window.playSelectedAnimation = playSelectedAnimation;
        window.changeCharacter = changeCharacter;
        window.toggleMusic = toggleMusic;
        window.adjustVolume = adjustVolume;
        window.sendMessage = sendMessage;
        window.sendChatMessage = sendChatMessage;
        window.handleKeyPress = handleKeyPress;
        window.handleChatKeyPress = handleChatKeyPress;
        // window.addMessage removed - using ElizaOS system
        window.updateStreamingMessageUI = updateStreamingMessageUI;
        window.showSpeechBubble = showSpeechBubble;
        window.updateSpeechBubbleContent = updateSpeechBubbleContent;
        
        // Integrate AI chat system
        let selectedCharacter = null;
        
        function initializeAIChat() {
            if (window.chatSystemV2 && selectedCharacter) {
                window.chatSystemV2.setCharacter(selectedCharacter);
                // console.log('💕 AI chat system V2 connected to character:', selectedCharacter.name);
                
                // Add welcome message (if new conversation)
                setTimeout(async () => {
                    const stats = await window.chatSystemV2.getUserStats();
                    if (!stats || stats.totalInteractions === 0) {
                        const welcomeMessage = getWelcomeMessage(selectedCharacter);
                        window.chatSystemV2.updateChatUI({
                            id: Date.now(),
                            sender: 'ai',
                            content: welcomeMessage,
                            timestamp: new Date().toISOString(),
                            emotion: 'happy'
                        });
                    }
                }, 1000);
            }
        }
        
        function getWelcomeMessage(character) {
            const timeContext = new Date().getHours();
            let greeting = 'Hello';
            if (timeContext < 12) greeting = 'Good morning';
            else if (timeContext < 18) greeting = 'Good afternoon';
            else greeting = 'Good evening';
            
            const welcomeMessages = {
                'Alice': `${greeting}! I'm Alice~ Nice to meet you! What would you like to chat about today?`,
                'Fliza': `${greeting}~ I'm Fliza, I've been waiting for you.`,
                'Ash': `Hmm...${greeting}, I'm Ash. Is there anything you'd like to say?`,
                'Elinyaa': `${greeting}! I'm Elinyaa~ Let's have a happy day!`,
                'default': `${greeting}! I'm ${character.name}, nice to meet you~`
            };
            return welcomeMessages[character.name] || welcomeMessages.default;
        }
        
        // Rewrite send message function to use AI system V2
        const originalSendChatMessage = sendChatMessage;
        sendChatMessage = function() {
            const input = document.getElementById('chat-input-field');
            const message = input.value.trim();
            if (!message) return;
            
            // Add send button animation
            const sendBtn = document.querySelector('.send-btn');
            sendBtn.classList.add('sending');
            setTimeout(() => {
                sendBtn.classList.remove('sending');
            }, 600);
            
            // Use AI chat system V2 to send message
            if (window.chatSystemV2 && selectedCharacter) {
                window.chatSystemV2.sendMessage(message);
                input.value = '';
            } else {
                // Fall back to original chat functionality
                originalSendChatMessage();
            }
        }
        
        // VRM表情触发函数（供AI系统调用）
        window.triggerVRMExpression = function(expression) {
            if (currentVrm && currentVrm.expressionManager) {
                const expressionMap = {
                    'smile': 'happy',
                    'wink': 'fun', 
                    'blush': 'happy',
                    'thinking': 'neutral',
                    'shy_smile': 'happy',
                    'nod': 'neutral',
                    'interested': 'surprised'
                };
                
                const vrmExpression = expressionMap[expression] || 'neutral';
                
                // Reset所有表情
                Object.keys(currentVrm.expressionManager.expressionMap).forEach(name => {
                    currentVrm.expressionManager.setValue(name, 0.0);
                });
                
                // Setup目标表情
                currentVrm.expressionManager.setValue(vrmExpression, 1.0);
                
                // 2秒后恢复中性表情
                setTimeout(() => {
                    if (currentVrm && currentVrm.expressionManager) {
                        currentVrm.expressionManager.setValue(vrmExpression, 0.0);
                    }
                }, 2000);
                
                // console.log(`😊 Triggering VRM expression: ${expression} -> ${vrmExpression}`);
            }
        };
        
        // Get character personality info
        function getCharacterPersonality(characterName) {
            const personalities = {
                'Fliza VRM': '温柔体贴的大姐姐类型，总是关心着你的感受。',
                'QuQu_U': '活泼可爱的萝莉，总是充满元气。',
                'Ash1.0': '酷酷的中性风女孩，有着独特的个人魅力。',
                'Elinyaa': '神秘优雅的精灵少女，有着不可思议的魅力。',
                'IMERIS': '高贵优雅的贵族少女，举止端庄。',
                'Maple': '温暖如秋日阳光的女孩，总是给人安全感。',
                'NEKONA': '可爱的猫娘，有着猫咪般的慵懒与活泼。',
                'RINDO_Full': '传统和风的大和抚子，温柔贤淑。',
                'Rainy': '活泼开朗的邻家女孩，总是充满活力。',
                'Vivi_model': '充满好奇心的探险家，总是对世界充满热情。',
                'Wolferia': '高傲的狼族公主，有着王者的气质。',
                'Yawl_Dress': '神秘的魔法少女，掌握着不可思议的力量。',
                'default': '温柔可爱的AI女友，总是陪伴在你身边。'
            };
            return personalities[characterName] || personalities.default;
        }

        // Get NPC character setting (for memory system)
        function getNPCPersona(npcId) {
            const personas = {
                'alice': '温柔可爱的邻家女孩，总是关心着user的感受，喜欢日常聊天和分享生活。性格开朗友善，善于倾听，会记住user的喜好和重要事件。',
                'fliza': '温柔体贴的大姐姐类型，成熟优雅，善解人意。总是用温暖的话语安慰user，会主动关心user的生活状态。',
                'ash': '酷酷的中性风女孩，有着独特的个人魅力，直率真诚。虽然表面冷淡，但内心温柔，会默默关心user。',
                'elinyaa': '神秘优雅的精灵少女，有着不可思议的魅力，喜欢诗歌和艺术。说话富有诗意，经常分享美好的事物。',
                'imeris': '高贵优雅的贵族少女，举止端庄，知识渊博。说话优雅得体，但也有可爱的一面。',
                'maple': '温暖如秋日阳光的女孩，总是给人安全感，喜欢烹饪和园艺。会分享生活小贴士，关心user的健康。',
                'nekona': '可爱的猫娘，有着猫咪般的慵懒与活泼，喜欢撒娇。说话时会带有"喵"的口癖，行为可爱迷人。',
                'rainy': '活泼开朗的邻家女孩，总是充满活力，喜欢运动和音乐。会鼓励user积极向上，分享快乐的事情。',
                'vivi': '充满好奇心的探险家，总是对世界充满热情，喜欢学习新事物。会和user分享有趣的知识和见解。',
                'wolferia': '高傲的狼族公主，有着王者的气质，但内心渴望被理解。外表高冷，但会逐渐展现温柔的一面。'
            };
            return personas[npcId] || personas['alice'];
        }

        // Use memory system to generate AI reply
        async function generateAIResponseWithMemory(userMessage, contextPrompt) {
            // Here should call your backend API or OpenAI API
            // Now return a simulated response first, replace after you configure API
            
            console.log('🧠 Using memory context to generate reply:', contextPrompt);
            
            // Temporarily use original AI reply system, but add memory info
            const baseResponse = generateAIResponse(userMessage);
            
            // Add some memory-related responses
            const memoryEnhancedResponses = [
                baseResponse,
                `${baseResponse} 我还记得你之前提到的事情呢~`,
                `${baseResponse} 根据我对你的了解，你应该会喜欢这个建议。`,
                `${baseResponse} 这让我想起了我们之前的对话。`
            ];
            
            return memoryEnhancedResponses[Math.floor(Math.random() * memoryEnhancedResponses.length)];
        }
        
        // Auto initialize AI chat system after VRM loading completes
        function onVRMLoadComplete(characterName, vrmPath) {
            selectedCharacter = {
                name: characterName.replace(' VRM', '').replace('_', ' '),
                personality: getCharacterPersonality(characterName),
                file: vrmPath,
                id: characterName
            };
            
            // Setupcharacter头像
            setCharacterAvatar(characterName);
            
            setTimeout(() => {
                initializeAIChat();
            }, 1500);
        }
        
        // Update手机状态栏时间
        function updatePhoneTime() {
            const timeDisplay = document.getElementById('phone-time');
            if (timeDisplay) {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false 
                });
                timeDisplay.textContent = timeString;
            }
        }
        
        // Update time every minute
        setInterval(updatePhoneTime, 60000);
        // Update time once immediately
        updatePhoneTime();
        
        window.goToCharacterSelect = goToCharacterSelect;
        window.initDragAndDrop = initDragAndDrop;

        // Initialize
        function init() {
            AppConfig.debug.info('🚀 AI Companion initialization started...');
            AppConfig.debug.log('🌐 Current page URL:', window.location.href);
            AppConfig.debug.log('📱 Wallet authenticator status:', walletAuth);
            
            // First perform wallet verification
            AppConfig.debug.log('⚡ Starting wallet verification...');
            const isAuthenticated = walletAuth.checkAuthentication();
            AppConfig.debug.log('🔐 Verification result:', isAuthenticated);
            
            if (!isAuthenticated) {
                console.log('❌ Wallet verification failed, stopping initialization');
                return; // If verification fails, don't continue initialization
            }
            
            AppConfig.debug.log('✅ Wallet verification successful, continuing app initialization');
            
            // User profile filling moved to character-select page, index.html only handles registered users
            
            // Check是否有选择的character，然后loadVRM
            loadSelectedCharacter();
            
            resizeRenderer();
            animate();

            // Initialize选择器
            initAnimationSelector();
            initCharacterSelector();
            
            // Initialize拖拽功能
            initDragAndDrop();

            // Initialize language switcher
            initLanguageToggle();

            // Initialize background music with multiple attempts
            function attemptMusicInit() {
                initBackgroundMusic();

                // Also try after user first interaction
                let userInteracted = false;
                function onFirstInteraction() {
                    if (!userInteracted) {
                        userInteracted = true;
                        // console.log('🎵 User interaction detected, attempting BGM start...');
                        setTimeout(() => {
                            if (backgroundMusic && !isMusicPlaying) {
                                // console.log('🎵 Retrying BGM after user interaction...');
                                playBackgroundMusic();
                            }
                        }, 500);

                        // Remove listeners after first interaction
                        document.removeEventListener('click', onFirstInteraction);
                        document.removeEventListener('keypress', onFirstInteraction);
                        document.removeEventListener('touchstart', onFirstInteraction);
                    }
                }

                document.addEventListener('click', onFirstInteraction);
                document.addEventListener('keypress', onFirstInteraction);
                document.addEventListener('touchstart', onFirstInteraction);
            }

            // Delay background music initialization to ensure DOM fully loaded
            setTimeout(() => {
                attemptMusicInit();
            }, 1000);

            // Initial state - check if elements exist
            const aiStatusElement = document.getElementById('ai-status');
            if (aiStatusElement) {
                aiStatusElement.innerHTML = '<span class="online-indicator"></span>' + i18n.t('status.ai.smart');
            }
            
            AppConfig.debug.info('🎉 AI Companion initialization completed');
        }

        // Load选择的character
        function loadSelectedCharacter() {
            try {
                // Get character info from wallet verification system
                const character = walletAuth.getCurrentCharacter();
                
                AppConfig.debug.log('📱 loadSelectedCharacter debug info:');
                // console.log('- character:', character);
                // console.log('- localStorage selectedCharacter:', localStorage.getItem('selectedCharacter'));
                
                if (character) {
                    // Update悬浮聊天框中的character名称
                    const characterNameElement = document.getElementById('character-name');
                    if (characterNameElement) {
                        characterNameElement.textContent = character.name;
                    }
                    
                    // Welcome message handled by ElizaOS system
                    
                    // Setup默认VRM文件
                    defaultVrmFile = character.file;
                    
                    // console.log(`✅ Character loaded: ${character.name} (wallet: ${walletAuth.formatAddress(character.walletAddress)})`);
                    // console.log(`📁 Setting defaultVrmFile: ${defaultVrmFile}`);
                    
                    // Setupcharacter头像（基于character.id）
                    if (character.id) {
                        setCharacterAvatar(character.id);
                    }
                    
                    // Now load VRM file
                    loadVRM();
                } else {
                    throw new Error('not foundcharacter信息');
                }
            } catch (error) {
                console.error('Failed to load character:', error);
                // Redirect to character selection page
                walletAuth.redirectToCharacterSelect();
            }
        }

        // Expose variables to global scope for button calls
        window.currentVrm = currentVrm;
        window.availableExpressions = availableExpressions;
        
        // Expose internal functions to global
        window.resetExpressions = resetExpressions;
        window.setExpression = setExpression;

        // Wait for DOM loading complete before initialization
        AppConfig.debug.log('🔍 Check DOM state:', document.readyState);
        AppConfig.debug.log('🔍 Init function exists:', typeof init);
        AppConfig.debug.log('⚙️ Module script execution completed, preparing initialization...');
        
        if (document.readyState === 'loading') {
            (window.AppConfig?.debug?.log || console.log)('DOM loading, waiting for DOMContentLoaded');
            document.addEventListener('DOMContentLoaded', () => {
                (window.AppConfig?.debug?.log || console.log)('DOMContentLoaded fired, calling init()');
                init();
                initMobileControls();
            });
        } else {
            // DOM already loaded
            (window.AppConfig?.debug?.log || console.log)('DOM loaded, calling init() immediately');
            init();
            initMobileControls();
        }

        // Mobile Controls Functionality
        function initMobileControls() {
            // Show mobile controls toggle button on mobile devices
            if (window.innerWidth <= 768) {
                // Mobile toggle button removed
            }

            // Mobile controls toggle functionality removed

            // Mobile chat drag functionality
            initMobileChatDrag();

            // Responsive layout adjustments
            handleResponsiveLayout();
        }

        function initMobileChatDrag() {
            const chatWindow = document.getElementById('floating-chat');
            if (!chatWindow) return;

            let startY = 0;
            let currentY = 0;
            let isDragging = false;
            const chatHeader = chatWindow.querySelector('.chat-header') || chatWindow.querySelector('.chat-window-header');

            if (chatHeader) {
                chatHeader.addEventListener('touchstart', (e) => {
                    if (window.innerWidth <= 768) {
                        startY = e.touches[0].clientY;
                        isDragging = true;
                    }
                });

                chatHeader.addEventListener('touchmove', (e) => {
                    if (!isDragging || window.innerWidth > 768) return;
                    
                    e.preventDefault();
                    currentY = e.touches[0].clientY - startY;
                    
                    // Limit drag range
                    const maxDrag = window.innerHeight * 0.4;
                    currentY = Math.max(-maxDrag, Math.min(maxDrag, currentY));
                    
                    chatWindow.style.transform = `translateY(${currentY}px)`;
                });

                chatHeader.addEventListener('touchend', () => {
                    if (!isDragging || window.innerWidth > 768) return;
                    
                    isDragging = false;
                    
                    // Snap to collapsed or expanded state
                    if (Math.abs(currentY) > 100) {
                        chatWindow.classList.toggle('collapsed');
                    }
                    
                    chatWindow.style.transform = '';
                    currentY = 0;
                });
            }
        }

        function handleResponsiveLayout() {
            function updateLayout() {
                const isMobile = window.innerWidth <= 768;
                // Mobile toggle button removed
                
                // Update body class for mobile layout
                document.body.classList.toggle('mobile-layout', isMobile);
            }

            window.addEventListener('resize', updateLayout);
            updateLayout(); // Initial call
        }
    </script>

    <script>
        // Global expression test function
        window.testShyExpression = function() {
            (window.AppConfig?.debug?.log || console.log)('Test bashful expression...');
            
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRM模型还未Loading complete！请等待load...');
                return;
            }

            console.log('Available expressions:', window.availableExpressions);
            
            // Reset所有表情
            if (window.resetExpressions) {
                window.resetExpressions();
            }
            
            // Try various shy-related expressions
            const shyExpressions = ['shy', 'embarrassed', 'blush', 'surprised', 'sad'];
            let appliedExpression = null;
            
            shyExpressions.forEach(expr => {
                if (window.availableExpressions && window.availableExpressions.includes(expr)) {
                    if (window.setExpression) {
                        window.setExpression(expr, 1.0);
                        appliedExpression = expr;
                        (window.AppConfig?.debug?.log || console.log)(`Applied expression: ${expr}`);
                    }
                }
            });
            
            if (appliedExpression) {
                document.getElementById('current-expression').textContent = `害羞 (${appliedExpression})`;
                // 5秒后恢复中性
                setTimeout(() => {
                    if (window.resetExpressions) {
                        window.resetExpressions();
                    }
                }, 5000);
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : '无';
                alert('当前VRM模型不支持害羞表情 😔\n\nAvailable expressions: ' + available + '\n\n建议：尝试点击其他表情按钮看看效果！');
            }
        };

        window.testHappyExpression = function() {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRM模型还未Loading complete！');
                return;
            }

            if (window.availableExpressions && window.availableExpressions.includes('happy')) {
                if (window.setExpression) {
                    window.setExpression('happy', 1.0);
                    document.getElementById('current-expression').textContent = '开心';
                    setTimeout(() => {
                        if (window.resetExpressions) {
                            window.resetExpressions();
                        }
                    }, 3000);
                }
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : '无';
                alert('当前VRM模型不支持开心表情\nAvailable expressions: ' + available);
            }
        };

        window.testSadExpression = function() {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRM模型还未Loading complete！');
                return;
            }

            if (window.availableExpressions && window.availableExpressions.includes('sad')) {
                if (window.setExpression) {
                    window.setExpression('sad', 1.0);
                    document.getElementById('current-expression').textContent = '难过';
                    setTimeout(() => {
                        if (window.resetExpressions) {
                            window.resetExpressions();
                        }
                    }, 3000);
                }
            } else {
                const available = window.availableExpressions ? window.availableExpressions.join(', ') : '无';
                alert('当前VRM模型不支持难过表情\nAvailable expressions: ' + available);
            }
        };

        window.resetAllExpressions = function() {
            if (!window.currentVrm || !window.currentVrm.expressionManager) {
                alert('VRM模型还未Loading complete！');
                return;
            }

            if (window.resetExpressions) {
                window.resetExpressions();
            }
            (window.AppConfig?.debug?.log || console.log)('All expressions reset');
        };
    </script>
    
    <!-- User profile registration panel -->

    <!-- Wallet connection overlay (initially hidden) -->
    
    <!-- User profile management moved to character-select page -->

    <!-- Wallet connection overlay (initially hidden) -->
    <div class="wallet-login-overlay" id="wallet-login-overlay" style="display: none;">
        <div class="wallet-login-panel">
            <div class="wallet-login-icon">🦊</div>
            <h2 class="wallet-login-title">连接wallet开始游戏</h2>
            <p class="wallet-login-subtitle">使用Solanawallet登录，与您的专属AI女友开始聊天</p>
            
            <button class="wallet-connect-btn" onclick="connectWallet()" id="wallet-connect-btn">
                连接wallet
            </button>
            
            <div class="wallet-options">
                <a href="https://phantom.app/" target="_blank" class="wallet-option">
                    <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #AB9FF2, #7B6BF0); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">P</div>
                    <span>Phantom</span>
                </a>
                <a href="https://solflare.com/" target="_blank" class="wallet-option">
                    <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #FF6B35, #F7931E); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">S</div>
                    <span>Solflare</span>
                </a>
            </div>
            
            <p style="font-size: 12px; color: #999; margin-top: 20px;">
                💡 没有wallet？点击上方图标安装后刷新页面
            </p>
        </div>
    </div>
    
    <!-- Initialize after page load -->
    <script>
        // Function to hide playing notifications
        function hidePlayingNotifications() {
            // Hide elements with "Playing" text
            const allElements = document.querySelectorAll('*');
            allElements.forEach(element => {
                if (element.textContent && element.textContent.includes('Playing')) {
                    const computedStyle = getComputedStyle(element);
                    if ((computedStyle.position === 'fixed' || computedStyle.position === 'absolute') &&
                        (computedStyle.right !== 'auto' || computedStyle.top !== 'auto')) {
                        element.style.display = 'none';
                    }
                }
            });
        }

        // Run periodically to catch dynamically created playing notifications
        setInterval(hidePlayingNotifications, 1000);

        // Also run on DOM mutations
        const observer = new MutationObserver(hidePlayingNotifications);
        observer.observe(document.body, { 
            childList: true, 
            subtree: true, 
            characterData: true 
        });

        document.addEventListener('DOMContentLoaded', function() {
            // Check是否从character selection页面跳转过来
            const hasStoredWallet = localStorage.getItem('wallet_address');
            const hasSelectedCharacter = localStorage.getItem('selectedCharacter');
            
            if (hasStoredWallet && hasSelectedCharacter) {
                (window.AppConfig?.debug?.log || console.log)('Redirected from character selection, initializing chat...');
                
                // Wallet already verified on character-select page, directly show logged in status
                
                // Temporarily skip memory system initialization, use OpenAI directly
                // console.log('⚠️ Skipping memory system initialization, using OpenAI chat directly');
                // console.log('💬 Chat system ready');"

                // User profile check moved to init() function, ensure immediate execution after wallet verification
                
                // Wait for chat system initialization
                setTimeout(() => {
                    if (window.chatSystemV2) {
                        // console.log('💬 Chat system ready');"
                    }
                }, 1000);
            }
        });
    </script>


    <style>












    </style>
</body>

</html>
